																(еще не доделано)
Адаптированая ИИ инфа от ишака Horizon на Python:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Основы языка:
-------------------------------------------------------------------------------------------------------------------------------------------------
Синтаксис и стиль:
Правила написания кода: отступы, разделение логических блоков, комментарии.
Документация кода: строки документации (docstrings) и использование PEP 257.
Кодстайл и соглашения: PEP 8, правила именования, лучшие практики.
-------------------------------------------------------------------------------------------------------------------------------------------------
Переменные и константы:
Именование переменных: допустимые символы, соглашения (_var, __var, одиночное _ для временных значений, разница между myVar и myvar).
Примитивные типы и литералы: числа (int, float, complex), строки, булевы значения, литералы (например, 42, 3.14, 'hello', True).
Специальные встроенные объекты.
Специальные переменные и константы.
-------------------------------------------------------------------------------------------------------------------------------------------------
Типы данных и структуры:
Примитивные типы: числа, строки, булевы значения.
Коллекции: списки, кортежи, множества, словари.
Дополнительные структуры: bytearray, bytes, memoryview.
Неизменяемые vs. изменяемые типы данных.
Основные встроенные структуры данных.
Литералы Python.
Представление чисел и кодирование данных.
-------------------------------------------------------------------------------------------------------------------------------------------------
Операторы:
Арифметические операторы (Mathematical Operators).
Операторы сравнения (Comparison Operators).
Логические операторы (Logical Operators).
Операторы присваивания (Assignment Operators).
Побитовые операторы (Bitwise Operators).
Операторы идентичности (Identity Operators).
Операторы принадлежности (Membership Operators).
-------------------------------------------------------------------------------------------------------------------------------------------------
Конструкции управления потоком:
Условные операторы: if, elif, else.
Циклы: for, while; операторы break, continue, pass.
Выход из функций: return, yield.
Обработка исключений: try, except, finally, raise, assert, del.
Конструкции для асинхронного кода.
-------------------------------------------------------------------------------------------------------------------------------------------------
Функции:
Определение функций: def, lambda.
Параметры и аргументы: позиционные, именованные, аргументы по умолчанию, переменное число аргументов (*args, **kwargs).
Встроенные функции Python (built-in functions).
Выход из программы (функции).
Операторы для работы с функциями и классами.
-------------------------------------------------------------------------------------------------------------------------------------------------
Статическая типизация и аннотации типов:
В современных версиях Python важную роль играют аннотации типов (PEP 484, PEP 526) и инструменты для их проверки (например, mypy, Pyright).
Это помогает повысить качество кода и обнаруживать ошибки на ранней стадии.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с памятью:
Механизмы сборки мусора, управление ссылками.
Встроенный модуль gc и нюансы работы с памятью в Python.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2. Объектно-ориентированное программирование (ООП):
-------------------------------------------------------------------------------------------------------------------------------------------------
Классы и объекты:
Создание классов: ключевое слово class, конструктор (init), использование self.
Атрибуты и методы экземпляра.
-------------------------------------------------------------------------------------------------------------------------------------------------
Магия языка (магические/dunder-методы):
Определение и применение: str, repr, len, getitem, setitem, add, sub, mul, truediv, eq, lt, gt, enter, exit, iter, next, del, call и т.д.
-------------------------------------------------------------------------------------------------------------------------------------------------
Принципы ООП:
Наследование: создание дочерних классов, множественное наследование, миксины.
Инкапсуляция: приватные и защищённые атрибуты (соглашения об использовании _ и __).
Полиморфизм: переопределение методов, динамическая диспетчеризация.
Абстракция: абстрактные классы и методы (модуль abc).
-------------------------------------------------------------------------------------------------------------------------------------------------
Метапрограммирование и декораторы:
Декораторы функций и методов: @classmethod, @staticmethod, @property.
Метаклассы: основы создания и применения.
Интроспекция и рефлексия: функции типа hasattr, getattr, setattr, isinstance, issubclass.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3. Модули, пакеты и экосистема:
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с файлами и директориями:
Методы файлового объекта:
close() – закрывает файл, освобождая ресурсы.
read() – считывает содержимое файла в строку/байты.
write() – записывает строку/байты в открытый файл.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с модулями:
Импорт модулей: import, from … import …, динамический импорт.
Стандартная библиотека Python: обзор наиболее часто используемых модулей (os, sys, math, datetime, random и др.).
-------------------------------------------------------------------------------------------------------------------------------------------------
Пакеты и дистрибуция:
Создание пакетов: структура каталогов, init.py.
Инструменты для упаковки: setuptools, distutils.
Менеджеры пакетов и виртуальные окружения: pip, venv, pipenv, poetry.
Документация: Sphinx, pydoc.
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты разработки:
Среды разработки (IDE): PyCharm, VSCode, и другие.
Линтеры и форматтеры: pylint, flake8, black, isort.
Системы контроля версий: Git и интеграция с Python-проектами.
Континуальная интеграция и развёртывание: CI/CD, Docker для Python.
-------------------------------------------------------------------------------------------------------------------------------------------------
Разработка нативных расширений:
Создание расширений на C/C++ для оптимизации производительности (через C API, Cython, Pybind11) остаётся важной
темой для высокопроизводительных приложений.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4. Функциональное программирование и расширенные конструкции:
-------------------------------------------------------------------------------------------------------------------------------------------------
Lambda-функции и анонимные выражения:
Создание и применение lambda-функций.
-------------------------------------------------------------------------------------------------------------------------------------------------
Функции высшего порядка:
Функции map(), filter(), reduce() (из модуля functools).
Comprehensions: списковые, словарные, множественные, генераторные выражения.
-------------------------------------------------------------------------------------------------------------------------------------------------
Итераторы и генераторы:
Создание итераторов: встроенные функции iter(), next(), enumerate().
Генераторы: определение функций с yield, генераторы списков и выражений.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
5. Типы данных и структуры:
-------------------------------------------------------------------------------------------------------------------------------------------------
Коллекции и структуры данных:
Списки: методы, срезы, сортировка.
Кортежи: неизменяемость, применение.
Множества: создание, операции и методы.
Словари: создание, перебор, методы.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с массивами и буферами:
Модуль array, bytearray, bytes, memoryview.
-------------------------------------------------------------------------------------------------------------------------------------------------
Строки и работа с текстом:
Методы строк, форматирование (f-строки, .format(), %).
Регулярные выражения (модуль re).
-------------------------------------------------------------------------------------------------------------------------------------------------
Дополнительные структуры:
Модули collections, deque, OrderedDict, Counter.
NamedTuple, dataclasses (с Python 3.7+).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
6. Алгоритмы и структуры данных:
-------------------------------------------------------------------------------------------------------------------------------------------------
Классические алгоритмы:
Сортировка: пузырьковая, быстрая, слиянием, вставками.
Поиск: линейный, бинарный поиск.
-------------------------------------------------------------------------------------------------------------------------------------------------
Структуры данных:
Очереди, стеки, связанные списки.
Деревья, графы: обходы, поиск в глубину и ширину.
Хеш-таблицы и словари.
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ сложности алгоритмов:
Основы Big O-нотации и оценка производительности.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
7. Многозадачность и параллельность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Потоки и процессы:
Многопоточность: модуль threading.
Многопроцессорность: модуль multiprocessing.
Библиотека concurrent.futures.
-------------------------------------------------------------------------------------------------------------------------------------------------
Асинхронное программирование:
Модуль asyncio: async/await, event loop.
Асинхронные генераторы и контекстные менеджеры (async for, async with).
Другие асинхронные фреймворки: Tornado, aiohttp.
-------------------------------------------------------------------------------------------------------------------------------------------------
Синхронизация и параллелизм:
Механизмы синхронизации: блокировки, семафоры, очереди.
Особенности работы с глобальной блокировкой интерпретатора (GIL).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
8. Библиотеки для работы с данными и научные вычисления:
-------------------------------------------------------------------------------------------------------------------------------------------------
Числовые вычисления и массивы:
NumPy: массивы, векторизация, математические функции.
SciPy: научные вычисления, оптимизация, статистика.
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ данных:
Pandas: работа с табличными данными, DataFrame, Series.
Инструменты для визуализации: Matplotlib, Seaborn, Plotly.
-------------------------------------------------------------------------------------------------------------------------------------------------
Машинное обучение и статистика:
Библиотеки машинного обучения: scikit-learn, TensorFlow, Keras, PyTorch.
Статистические модели и анализ: statsmodels, Dask для обработки больших данных.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
9. Тестирование, отладка и профилирование:
-------------------------------------------------------------------------------------------------------------------------------------------------
Тестирование:
Юнит-тестирование: модули unittest, pytest.
Интеграционное тестирование и TDD.
Инструменты для оценки покрытия кода (coverage.py).
-------------------------------------------------------------------------------------------------------------------------------------------------
Отладка:
Стандартный отладчик pdb (и его расширения ipdb).
Логирование: модуль logging, настройки уровней логов.
-------------------------------------------------------------------------------------------------------------------------------------------------
Профилирование и оптимизация:
Профилировщики: cProfile, line_profiler, memory_profiler.
Инструменты оптимизации: timeit, анализ потребления памяти.
Использование JIT-компиляции (PyPy), Cython, Numba.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
10. Веб-разработка:
-------------------------------------------------------------------------------------------------------------------------------------------------
Фреймворки для создания веб-приложений:
Классические: Django, Flask.
Асинхронные: FastAPI, aiohttp, Tornado.
Дополнительные фреймворки: web2py, Pyramid.
-------------------------------------------------------------------------------------------------------------------------------------------------
REST API и микросервисы:
Создание RESTful API, работа с JSON.
GraphQL, SOAP (если необходимо).
Интеграция с внешними сервисами.
-------------------------------------------------------------------------------------------------------------------------------------------------
Веб-технологии и фронтенд:
Основы HTML, CSS, JavaScript для интеграции с Python-бэкендом.
Шаблонизаторы: Jinja2, Mako.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11. Интерфейсы и графика:
-------------------------------------------------------------------------------------------------------------------------------------------------
Графические пользовательские интерфейсы (GUI):
Tkinter: стандартный модуль для создания GUI.
PyQt / PySide: интерфейсы с использованием Qt.
Kivy: для создания мульти-тач и кроссплатформенных приложений.
Дополнительные решения: Streamlit, Dash (для веб-интерфейсов).
-------------------------------------------------------------------------------------------------------------------------------------------------
Игровая разработка:
Pygame: разработка 2D-игр.
Другие библиотеки для игр и визуализации.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
12. Работа с базами данных:
-------------------------------------------------------------------------------------------------------------------------------------------------
SQL и реляционные базы данных:
SQLite: работа с локальными базами.
PostgreSQL, MySQL: подключение, драйверы (psycopg2, mysql-connector).
ORM: SQLAlchemy, Django ORM, Peewee.
-------------------------------------------------------------------------------------------------------------------------------------------------
NoSQL базы данных:
Работа с MongoDB (PyMongo).
Другие NoSQL решения (Redis, Cassandra).
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты миграций и администрирования:
Alembic для миграций, администрирование через оболочки.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
13. Оптимизация и производительность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Профилирование и оптимизация кода:
Анализ производительности, оптимизация алгоритмов.
Использование встроенных инструментов (timeit, cProfile).
Применение внешних библиотек: Numba, Cython, PyPy.
-------------------------------------------------------------------------------------------------------------------------------------------------
Управление памятью и сборка мусора:
Тонкости работы сборщика мусора, reference counting.
Модули для мониторинга использования памяти.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
14. Безопасность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Безопасное программирование:
Лучшие практики: валидация данных, защита от SQL-инъекций, обработка исключений.
Безопасность веб-приложений: защита сессий, XSS, CSRF.
-------------------------------------------------------------------------------------------------------------------------------------------------
Криптография и шифрование:
Библиотеки: cryptography, PyCryptodome.
Работа с SSL/TLS, безопасное хранение данных.
-------------------------------------------------------------------------------------------------------------------------------------------------
Аудит и тестирование безопасности:
Инструменты статического и динамического анализа кода.
-------------------------------------------------------------------------------------------------------------------------------------------------
Продвинутые аспекты безопасности:
Помимо базовых мер, можно добавить темы статического и динамического анализа безопасности,
инструменты для поиска уязвимостей и рекомендации по безопасному программированию.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
15. Работа с внешними сервисами и протоколами:
-------------------------------------------------------------------------------------------------------------------------------------------------
HTTP и REST:
Библиотеки для HTTP-запросов: requests, urllib.
Работа с API: RESTful, GraphQL, SOAP.
-------------------------------------------------------------------------------------------------------------------------------------------------
Протоколы и сетевое взаимодействие:
Работа с email (smtplib, email).
FTP, SFTP, WebSocket.
Сетевое программирование: сокеты (модуль socket).
-------------------------------------------------------------------------------------------------------------------------------------------------
Обработка форматов данных:
JSON, XML, CSV: чтение, запись, сериализация и десериализация.
-------------------------------------------------------------------------------------------------------------------------------------------------
Разработка микросервисов и распределённых систем:
Глубокое рассмотрение подходов к созданию микросервисной архитектуры, использование брокеров сообщений (RabbitMQ, Kafka),
а также распределённых вычислительных систем (например, Celery для задач) дополнит понимание масштабируемости приложений.
-------------------------------------------------------------------------------------------------------------------------------------------------
Интеграция с облачными технологиями:
Работа с облачными SDK (например, boto3 для AWS, библиотеки для Google Cloud или Azure) и особенностями развёртывания Python-приложений в облаке.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
16. Разное и дополнительные темы:
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с датами, временем и локализацией:
Модули: datetime, time, calendar.
Локализация и интернационализация: locale, gettext.
-------------------------------------------------------------------------------------------------------------------------------------------------
Сетевое программирование и системы:
Модуль os: работа с файловой системой, переменные окружения.
Модуль subprocess: выполнение внешних команд.
Автоматизация: скрипты для командной строки, работа с терминалом (argparse, click).
-------------------------------------------------------------------------------------------------------------------------------------------------
Метапрограммирование:
Интроспекция: функции dir(), getattr(), setattr(), isinstance(), issubclass().
Декораторы, метаклассы, модуль inspect.
-------------------------------------------------------------------------------------------------------------------------------------------------
Парадигмы программирования:
Императивное, объектно-ориентированное, функциональное, процедурное.
Аспектно-ориентированное программирование (при необходимости).
-------------------------------------------------------------------------------------------------------------------------------------------------
Сообщество и экосистема:
ПEP-процесс: разработка и обсуждение стандартов.
Конференции, сообщества, открытый исходный код (GitHub, PyPI).
Лицензирование и правовые аспекты.
-------------------------------------------------------------------------------------------------------------------------------------------------
Дизайн-паттерны и архитектурные решения:
Хотя базовые принципы ООП и метапрограммирования включены,
отдельный раздел по дизайн-паттернам (например, Singleton, Factory, Observer, MVC и т.д.) применительно
к Python поможет в построении масштабируемых архитектур.
-------------------------------------------------------------------------------------------------------------------------------------------------
Дополнительные парадигмы и современные архитектуры:
Рассмотрение событийно-ориентированных архитектур, функциональных реактивных подходов и других современных методик разработки,
которые находят применение в Python.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
17. Научные вычисления, анализ данных и машинное обучение:
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ данных:
Инструменты для работы с большими данными: Dask, PySpark.
Библиотеки визуализации: seaborn, plotly, bokeh.
-------------------------------------------------------------------------------------------------------------------------------------------------
Машинное обучение и искусственный интеллект:
Основные библиотеки: scikit-learn, TensorFlow, Keras, PyTorch.
Специализированные модули для обработки изображений, текста, звука.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
18. Инструменты разработки, тестирования и развёртывания:
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты и среды:
IDE, редакторы кода, Jupyter Notebook/Lab.
Системы контроля версий, интеграция с CI/CD (GitLab CI, GitHub Actions).
Документация, генерация документации (Sphinx, MkDocs).
-------------------------------------------------------------------------------------------------------------------------------------------------
Контейнеризация и виртуализация:
Docker, Kubernetes для развёртывания Python-приложений.
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты и практики DevOps для Python:
Включая контейнеризацию (Docker, Kubernetes), системы CI/CD (GitHub Actions, GitLab CI) и автоматизацию развёртывания,
что особенно важно для современных проектов.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1. Основы языка:
-------------------------------------------------------------------------------------------------------------------------------------------------
Синтаксис и стиль:
Правила написания кода: отступы, разделение логических блоков, комментарии.
Документация кода: строки документации (docstrings) и использование PEP 257.
Кодстайл и соглашения: PEP 8, правила именования, лучшие практики.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Синтаксис и стиль
Отступы и блоки кода:
Python использует отступы для определения блоков кода вместо фигурных скобок, как во многих других языках.
Рекомендуется использовать 4 пробела для каждого уровня отступа.

Пример:
def greet(name):
    if name:
        print(f"Привет, {name}!")
    else:
        print("Привет!")

Разделение логических блоков:
Логически связанные части кода лучше отделять пустыми строками. Это улучшает читаемость и позволяет быстро находить нужные фрагменты.

Комментарии:
Комментарии служат для пояснения неочевидной логики или важной информации о том, почему код работает именно так, как написан.

Inline-комментарии: располагаются после кода на той же строке (если пояснение короткое).
Блочные комментарии: располагаются над фрагментом кода и объясняют его назначение.

Пример:
# Проверяем, что значение больше нуля
if value > 0:
    print("Положительное число")  # Выводим сообщение

Документация кода: Docstrings и PEP 257
Docstrings:
Строки документации (docstrings) — это способ документировать модули, классы и функции.
Они располагаются сразу после объявления и заключаются в тройные кавычки (обычно двойные кавычки).

Пример:
def add(a, b):
    """
    Функция для сложения двух чисел.

    :param a: Первое слагаемое.
    :param b: Второе слагаемое.
    :return: Сумма a и b.
    """
    return a + b

PEP 257:
Этот документ описывает соглашения для написания docstrings.
Основные моменты:
Первая строка должна быть кратким описанием цели функции или класса.
Если требуется подробное описание, после первой строки должна идти пустая строка, а затем — более подробное объяснение.
Используйте императивное наклонение (например, «Возвращает», «Создает») для описания функций.

Кодстайл и соглашения: PEP 8
Общие рекомендации PEP 8:
Отступы: используйте 4 пробела для каждого уровня отступа.
Длина строки: стараетесь, чтобы строки не превышали 79 символов (это упрощает чтение кода на небольших экранах и в редакторах).
Пробелы: ставьте пробел после запятых, вокруг операторов (например, a = b + c) и после ключевых слов.
Разделение кода: между функциями и классами рекомендуется оставлять по две пустые строки, а внутри классов — одну пустую строку между методами.

Именование:
Переменные и функции: использовать стиль snake_case (например, my_variable, calculate_sum).

Классы: именуются в стиле CamelCase (например, MyClass).

Константы: записываются заглавными буквами с подчеркиваниями (например, MAX_VALUE).

Лучшие практики:
Пишите код так, чтобы он был понятен не только вам, но и другим разработчикам.
Следуйте общепринятым соглашениям, чтобы улучшить поддержку и читаемость вашего кода.
Комментарии должны объяснять «почему» было принято то или иное решение,
а не «что» делает код — само понятное написание кода должно объяснять его действие.
-------------------------------------------------------------------------------------------------------------------------------------------------
Переменные и константы:
Именование переменных: допустимые символы, соглашения (_var, __var, одиночное _ для временных значений, разница между myVar и myvar).
Примитивные типы и литералы: числа (int, float, complex), строки, булевы значения, литералы (например, 42, 3.14, 'hello', True).
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
1…9a…z - ❌ 
a…z1…9 - ✅
_a…z1…9 - ✅
_var → это соглашение, означающее переменную для "внутреннего использования" в коде, но не скрытую (например, для использования в модулях).
__var → это обфускация (или же использование двойного подчёркивания для создания "защищённого" атрибута или метода внутри классов).
_ → часто используется как "неважная переменная" (например, в цикле for _ in range(5):)
myVar и myvar — это разные переменные.
_ (одиночное подчеркивание) – соглашение для "временных" переменных, игнорируемых значений, 
но _ также используется для хранения последнего результата в интерактивном режиме Python.

Примитивные типы и литералы:

Литералы – это фиксированные значения, которые записаны непосредственно в исходном коде. К ним относятся:

Числовые литералы:

Целые числа (int):
Можно задавать в десятичном виде (например, 42), а также в других системах:

Бинарные: с префиксом 0b (например, 0b1010)
Восьмеричные: с префиксом 0o (например, 0o52)
Шестнадцатеричные: с префиксом 0x (например, 0x2A)
Допускается использование символа подчёркивания для улучшения читаемости (например, 1_000_000).

Числа с плавающей точкой (float):
Например, 3.14, 0.001, а также экспоненциальная запись – 1e10, 2.5E-4.

Комплексные числа (complex):
Обозначаются с суффиксом j (например, 1+2j, 3j).

Строковые литералы:

Обычные строки:
Задаются в одинарных ('hello') или двойных ("world") кавычках.

Многострочные строки:
Обрамляются тройными кавычками – одинарными ('''текст''') или двойными ("""текст""").

Сырые строки (raw strings):
С префиксом r или R (например, r"\n" будет содержать два символа — обратный слеш и букву n, а не перенос строки).

Bytes-литералы:
Задаются с префиксом b или B (например, b"data").

f-строки (форматированные строки):
С префиксом f или F (например, f"Value: {value}"), позволяют встраивать выражения внутри строк.

Контейнерные литералы:

Эти литералы позволяют создавать составные структуры данных:

Списки:
Записываются в квадратных скобках, например: [1, 2, 3].

Кортежи:
Записываются в круглых скобках, например: (1, 2, 3).
Обратите внимание, что односоставной кортеж записывается с запятой: (42,).

Множества:
Ненулевые множества задаются фигурными скобками, например: {1, 2, 3}.
Для пустого множества нельзя использовать {} (оно интерпретируется как пустой словарь), вместо этого применяется функция set().

Словари:
Записываются в фигурных скобках с парами ключ:значение, например: {'a': 1, 'b': 2}.

Булевы литералы:
Логические значения:
True и False представляют два булевых значения.

Специальные литералы:

None:
Представляет отсутствие значения или пустоту.

Ellipsis:
Записывается как троеточие ... и используется, например, в срезах расширенных структур или как заполнитель.

Специальные объекты Python:
В Python все является объектом. Помимо примитивных типов, объекты могут представлять:
Функции: объявленные с помощью ключевого слова def.
Классы: создаются через class.
Модули: файлы с кодом, которые можно импортировать.

Специальные встроенные объекты:
Некоторые объекты, такие как None, Ellipsis и NotImplemented,
имеют особое значение в языке и используются для обозначения специальных состояний или условий.

Специальные переменные и константы:
Специальные переменные:
Переменные с двойными подчеркиваниями, например, __name__, __file__ или __doc__,
используются для хранения служебной информации о модуле, классе или функции.
Например, переменная __name__ позволяет определить, выполняется ли модуль как основной скрипт или импортируется в другой модуль.

Константы:
В Python отсутствует механизм, гарантирующий неизменяемость переменной.
Однако по договорённости переменные, которые не должны изменяться, именуются заглавными буквами, например, PI = 3.14159 или MAX_SIZE = 100.



Специальные переменные и константы:
__name__ – имя текущего модуля (__main__, если исполняется напрямую)
__doc__ – строка документации модуля/функции
__file__ – путь к файлу модуля
__debug__ – True, если код выполняется без python -O
-------------------------------------------------------------------------------------------------------------------------------------------------
Типы данных и структуры:
Примитивные типы: числа, строки, булевы значения.
Коллекции: списки, кортежи, множества, словари.
Дополнительные структуры: bytearray, bytes, memoryview.
Неизменяемые vs. изменяемые типы данных.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Основные встроенные структуры данных
int – целые числа
float – числа с плавающей запятой
complex – комплексные числа
str – строки
list – списки
tuple – кортежи
dict – словари
set – множества
bool – логический тип

Литералы Python:
int: 42
float: 3.14
str: 'hello'
bool: True
list: [1, 2, 3]
tuple: (1, 2, 3)
dict: {'key': 'value'}
set: {1, 2, 3}

Представление чисел и кодирование данных:
Символ	Десятичный	Двоичный	Восьмеричный	Шестнадцатиричный	Base32		Base64
a		97			1100001		141				61					ME======	YQ==
b		98			1100010		142				62					MF======	Yg==
c		99			1100011		143				63					MG======	Yw==
d		100			1100100		144				64					MH======	ZA==
e		101			1100101		145				65					MI======	ZQ==
f		102			1100110		146				66					MJ======	Zg==
g		103			1100111		147				67					MK======	Zw==
h		104			1101000		150				68					ML======	aA==
i		105			1101001		151				69					MM======	aQ==
j		106			1101010		152				6A					MN======	ag==
k		107			1101011		153				6B					MO======	aw==
l		108			1101100		154				6C					MP======	bA==
m		109			1101101		155				6D					MQ======	bQ==
n		110			1101110		156				6E					MR======	bg==
o		111			1101111		157				6F					MS======	bw==
p		112			1110000		160				70					pMT======	cA==
q		113			1110001		161				71					MU======	cQ==
r		114			1110010		162				72					MV======	cg==
s		115			1110011		163				73					MW======	cw==
t		116			1110100		164				74					MX======	dA==
u		117			1110101		165				75					MY======	dQ==
v		118			1110110		166				76					MZ======	dg==
w		119			1110111		167				77					M2======	dw==
x		120			1111000		170				78					M3======	eA==
y		121			1111001		171				79					M4======	eQ==
z		122			1111010		172				7A					M5======	eg==
"""
Base32 и Base64 — это не системы счисления в привычном смысле, а методы кодирования данных.
Они используются для представления бинарных данных в текстовом виде, например, в передаче данных по сети или хранении в текстовых форматах.
Тем не менее, их можно воспринимать как системы счисления с основанием 32 и 64,
потому что они используют 32 или 64 символа для представления данных.

🔹 Base32
Использует 32 символа:
ABCDEFGHIJKLMNOPQRSTUVWXYZ234567
(цифры 0 и 1 не используются, чтобы избежать путаницы с O и I).

🔹 Base64
Использует 64 символа:
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

Base64 часто используется для кодирования изображений, файлов, передачи данных в e-mail (MIME) и JSON Web Token (JWT).

Base32 использует 5-битные блоки → требует добавления = для выравнивания.
Base64 использует 6-битные блоки → тоже добавляет = при необходимости.
"""
-------------------------------------------------------------------------------------------------------------------------------------------------
Операторы:
Арифметические операторы: +, -, *, /, //, %, **.
Операторы сравнения: ==, !=, >, <, >=, <=.
Логические операторы: and, or, not.
Побитовые операторы: &, |, ^, ~, <<, >>.
Операторы присваивания: =, +=, -=, *=, /=, //=, %=, **=, и др.
Операторы идентичности: is, is not.
Операторы принадлежности: in, not in.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Арифметические операторы (Mathematical Operators):
Оператор	Описание				Пример
+			сложение				2 + 3 → 5
-			вычитание				5 - 2 → 3
*			умножение				3 * 4 → 12
/			деление					10 / 2 → 5.0
//			целочисленное деление	10 // 3 → 3
%			остаток от деления		10 % 3 → 1
**			возведение в степень	2 ** 3 → 8

Операторы сравнения (Comparison Operators):
Оператор	Описание			Пример
==			равно				5 == 5 → True
!=			не равно			5 != 3 → True
>			больше				5 > 3 → True
<			меньше				3 < 5 → True
>=			больше или равно	5 >= 5 → True
<=			меньше или равно	3 <= 5 → True

Логические операторы (Logical Operators):
Оператор	Описание			Пример
and			логическое И		True and False → False
or			логическое ИЛИ		True or False → True
not			логическое НЕ		not True → False

Операторы присваивания (Assignment Operators):
Оператор	Описание								Пример
=			простое присваивание					x = 5
+=			сложение и присваивание					x += 3 → x = x + 3
-=			вычитание и присваивание				x -= 3 → x = x - 3
*=			умножение и присваивание				x *= 3 → x = x * 3
/=			деление и присваивание					x /= 3 → x = x / 3
//=			целочисленное деление и присваивание	x //= 3 → x = x // 3
%=			остаток от деления и присваивание		x %= 3 → x = x % 3
**=			возведение в степень и присваивание		x **= 3 → x = x ** 3
&=			побитовое И и присваивание				x &= 3 → x = x & 3
|=			побитовое ИЛИ и присваивание			`x
^=			побитовое XOR и присваивание			x ^= 3 → x = x ^ 3
>>=			побитовый сдвиг вправо и присваивание	x >>= 3 → x = x >> 3
<<=			побитовый сдвиг влево и присваивание	x <<= 3 → x = x << 3

Побитовые операторы (Bitwise Operators):
Оператор	Описание			Пример
&			побитовое И			5 & 3 → 1
|			побитовое ИЛИ		`5
^			побитовое XOR		5 ^ 3 → 6
~			побитовое НЕ		~5 → -6
<<			сдвиг влево			5 << 1 → 10
>>			сдвиг вправо		5 >> 1 → 2

Операторы идентичности (Identity Operators):
#Используются для проверки, указывают ли две переменные на один объект в памяти:
Оператор	Описание				Пример
is			идентичен ли объект		x is y
is not		не идентичен ли объект	x is not y

Операторы принадлежности (Membership Operators):
#Используются для проверки, содержится ли значение в последовательности:
Оператор	Описание							Пример
in			проверяет, содержится ли элемент	'a' in 'apple'
not in		проверяет, отсутствует ли элемент	'b' not in 'apple'
-------------------------------------------------------------------------------------------------------------------------------------------------
Конструкции управления потоком:
Условные операторы: if, elif, else.
Циклы: for, while; операторы break, continue, pass.
Выход из функций: return, yield.
Обработка исключений: try, except, finally, raise, assert, del.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Конструкции для асинхронного кода:
async – определяет асинхронную функцию
async def – объявление асинхронной корутины (функции)
await – ожидание результата корутины
async for – асинхронный цикл for
async with – асинхронный менеджер контекста

Операторы управления потоком выполнения (Control Flow Statements):
Оператор	Описание
if			условный оператор
elif		альтернативное условие
else		ветка, выполняющаяся, если условия выше не сработали
for			цикл for
while		цикл while
break		выход из цикла
continue	переход к следующей итерации цикла
pass		пустая операция-заглушка
return		выход из функции с возвратом значения
yield		приостанавливает выполнение генератора и возвращает значение
raise		возбуждает исключение
try			блок для обработки исключений
except		обработка конкретного исключения
finally		блок, который выполняется всегда
assert		проверяет условие и возбуждает AssertionError, если оно ложно
del()		удаляет объект или переменную из памяти.
-------------------------------------------------------------------------------------------------------------------------------------------------
Функции:
Определение функций: def, lambda.
Параметры и аргументы: позиционные, именованные, аргументы по умолчанию, переменное число аргументов (*args, **kwargs).
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Встроенные функции Python (built-in functions):
abs() – модуль числа
aiter() – возвращает асинхронный итератор объекта
all() – возвращает True, если все элементы в итерируемом объекте истинны
any() – возвращает True, если хотя бы один элемент истинный
anext() – извлекает следующий элемент из асинхронного итератора.
ascii() – строковое представление объекта с ASCII-символами
bin() – преобразует число в двоичную строку
bool() – преобразует значение в True или False
breakpoint() – точка останова в отладчике
bytearray() – создаёт изменяемую последовательность байтов
bytes() – создаёт неизменяемую последовательность байтов
callable() – проверяет, можно ли вызывать объект
chr() – возвращает символ по коду Unicode
compile() – компилирует строку кода в объект-скрипт
complex() – создаёт комплексное число
delattr() – удаляет атрибут у объекта
dict() – создаёт словарь
dir() – возвращает список атрибутов объекта
divmod() – возвращает (x // y, x % y)
enumerate() – создаёт объект-итератор с индексами
eval() – выполняет строку как код
exec() – выполняет строку как программу
filter() – фильтрует элементы через функцию
float() – преобразует в число с плавающей точкой
format() – форматирует строку
frozenset() – создаёт неизменяемое множество
getattr() – получает атрибут объекта
globals() – возвращает глобальные переменные
hasattr() – проверяет, есть ли у объекта атрибут
hash() – возвращает хеш объекта
help() – выводит справку
hex() – переводит число в шестнадцатеричную систему
id() – возвращает уникальный идентификатор объекта
input() – получает ввод от пользователя
int() – преобразует в целое число
isinstance() – проверяет, принадлежит ли объект классу
issubclass() – проверяет, является ли класс подклассом
iter() – создаёт итератор
len() – возвращает длину объекта
list() – создаёт список
locals() – возвращает локальные переменные
map() – применяет функцию ко всем элементам последовательности
max() – возвращает максимум из списка
min() – возвращает минимум из списка
memoryview() – представляет объект в виде сырой памяти
next() – получает следующий элемент итератора
__new__() – создание экземпляра перед __init__()
object() – базовый класс всех классов
oct() – переводит число в восьмеричную систему
open() – открывает файл в указанном режиме.
ord() – возвращает Unicode-код символа
pow() – возводит число в степень
print() – выводит данные в консоль
property() – создаёт свойство объекта
range() – создаёт последовательность чисел
repr() – возвращает строковое представление объекта
reversed() – создаёт обратный итератор
round() – округляет число
set() – создаёт множество
setattr() – устанавливает атрибут объекта
slice() – создаёт объект среза
sorted() – сортирует последовательность
str() – преобразует объект в строку
sum() – суммирует элементы
super() – вызывает метод родительского класса
tuple() – создаёт кортеж
type() – возвращает тип объекта или создаёт новый класс
vars() – возвращает __dict__ объекта
zip() – объединяет элементы последовательностей в кортежи

Выход из программы:
exit(), quit() – мягкий выход.
sys.exit() – жёсткий выход (требует import sys).

Операторы для работы с функциями и классами:
Оператор	Описание
def			объявление функции
lambda		создание анонимной функции
class		объявление класса
return		возврат значения из функции
yield		создание генератора
global		объявление глобальной переменной внутри функции
nonlocal	доступ к переменной внешней области видимости в функции
-------------------------------------------------------------------------------------------------------------------------------------------------
Статическая типизация и аннотации типов:
В современных версиях Python важную роль играют аннотации типов (PEP 484, PEP 526) и инструменты для их проверки (например, mypy, Pyright).
Это помогает повысить качество кода и обнаруживать ошибки на ранней стадии.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с памятью:
Механизмы сборки мусора, управление ссылками.
Встроенный модуль gc и нюансы работы с памятью в Python.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
2. Объектно-ориентированное программирование (ООП):
-------------------------------------------------------------------------------------------------------------------------------------------------
Классы и объекты:
Создание классов: ключевое слово class, конструктор (init), использование self.
Атрибуты и методы экземпляра.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Классы и ООП
class – создание класса
__init__() – конструктор
self – ссылка на текущий объект
@classmethod – позволяет вызывать метод на уровне класса, передавая cls вместо self
@staticmethod – определяет метод, не зависящий от экземпляра и класса, без self и cls
@property – свойство класса
(self и cls не зарезервированные слова, но их принято использовать по соглашению)
-------------------------------------------------------------------------------------------------------------------------------------------------
Магия языка (магические/dunder-методы):
Определение и применение: str, repr, len, getitem, setitem, add, sub, mul, truediv, eq, lt, gt, enter, exit, iter, next, del, call и т.д.
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
Магические методы (dunder-методы, __xxx__):
__str__(), __repr__() – строковое представление
__len__(), __getitem__(), __setitem__() – поведение контейнеров
__add__(), __sub__(), __mul__(), __truediv__() – арифметика
__eq__(), __lt__(), __gt__() – сравнение
__enter__(), __exit__() – менеджеры контекста (with)
__iter__(), __next__() – поддержка итераторов
__del__() – финализатор объекта
__call__() – делает экземпляр класса вызываемым, как функцию
-------------------------------------------------------------------------------------------------------------------------------------------------
Принципы ООП:
Наследование: создание дочерних классов, множественное наследование, миксины.
Инкапсуляция: приватные и защищённые атрибуты (соглашения об использовании _ и __).
Полиморфизм: переопределение методов, динамическая диспетчеризация.
Абстракция: абстрактные классы и методы (модуль abc).
-------------------------------------------------------------------------------------------------------------------------------------------------
Метапрограммирование и декораторы:
Декораторы функций и методов: @classmethod, @staticmethod, @property.
Метаклассы: основы создания и применения.
Интроспекция и рефлексия: функции типа hasattr, getattr, setattr, isinstance, issubclass.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3. Модули, пакеты и экосистема:
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с файлами и директориями:
Методы файлового объекта:
close() – закрывает файл, освобождая ресурсы.
read() – считывает содержимое файла в строку/байты.
write() – записывает строку/байты в открытый файл.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с модулями:
Импорт модулей: import, from … import …, динамический импорт.
Стандартная библиотека Python: обзор наиболее часто используемых модулей (os, sys, math, datetime, random и др.).
-------------------------------------------------------------------------------------------------------------------------------------------------
Пакеты и дистрибуция:
Создание пакетов: структура каталогов, init.py.
Инструменты для упаковки: setuptools, distutils.
Менеджеры пакетов и виртуальные окружения: pip, venv, pipenv, poetry.
Документация: Sphinx, pydoc.
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты разработки:
Среды разработки (IDE): PyCharm, VSCode, и другие.
Линтеры и форматтеры: pylint, flake8, black, isort.
Системы контроля версий: Git и интеграция с Python-проектами.
Континуальная интеграция и развёртывание: CI/CD, Docker для Python.
-------------------------------------------------------------------------------------------------------------------------------------------------
Разработка нативных расширений:
Создание расширений на C/C++ для оптимизации производительности (через C API, Cython, Pybind11) остаётся важной
темой для высокопроизводительных приложений.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4. Функциональное программирование и расширенные конструкции:
-------------------------------------------------------------------------------------------------------------------------------------------------
Lambda-функции и анонимные выражения:
Создание и применение lambda-функций.
-------------------------------------------------------------------------------------------------------------------------------------------------
Функции высшего порядка:
Функции map(), filter(), reduce() (из модуля functools).
Comprehensions: списковые, словарные, множественные, генераторные выражения.
-------------------------------------------------------------------------------------------------------------------------------------------------
Итераторы и генераторы:
Создание итераторов: встроенные функции iter(), next(), enumerate().
Генераторы: определение функций с yield, генераторы списков и выражений.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
5. Типы данных и структуры:
-------------------------------------------------------------------------------------------------------------------------------------------------
Коллекции и структуры данных:
Списки: методы, срезы, сортировка.
Кортежи: неизменяемость, применение.
Множества: создание, операции и методы.
Словари: создание, перебор, методы.
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с массивами и буферами:
Модуль array, bytearray, bytes, memoryview.
-------------------------------------------------------------------------------------------------------------------------------------------------
Строки и работа с текстом:
Методы строк, форматирование (f-строки, .format(), %).
Регулярные выражения (модуль re).
-------------------------------------------------------------------------------------------------------------------------------------------------
Дополнительные структуры:
Модули collections, deque, OrderedDict, Counter.
NamedTuple, dataclasses (с Python 3.7+).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
6. Алгоритмы и структуры данных:
-------------------------------------------------------------------------------------------------------------------------------------------------
Классические алгоритмы:
Сортировка: пузырьковая, быстрая, слиянием, вставками.
Поиск: линейный, бинарный поиск.
-------------------------------------------------------------------------------------------------------------------------------------------------
Структуры данных:
Очереди, стеки, связанные списки.
Деревья, графы: обходы, поиск в глубину и ширину.
Хеш-таблицы и словари.
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ сложности алгоритмов:
Основы Big O-нотации и оценка производительности.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
7. Многозадачность и параллельность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Потоки и процессы:
Многопоточность: модуль threading.
Многопроцессорность: модуль multiprocessing.
Библиотека concurrent.futures.
-------------------------------------------------------------------------------------------------------------------------------------------------
Асинхронное программирование:
Модуль asyncio: async/await, event loop.
Асинхронные генераторы и контекстные менеджеры (async for, async with).
Другие асинхронные фреймворки: Tornado, aiohttp.
-------------------------------------------------------------------------------------------------------------------------------------------------
Синхронизация и параллелизм:
Механизмы синхронизации: блокировки, семафоры, очереди.
Особенности работы с глобальной блокировкой интерпретатора (GIL).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
8. Библиотеки для работы с данными и научные вычисления:
-------------------------------------------------------------------------------------------------------------------------------------------------
Числовые вычисления и массивы:
NumPy: массивы, векторизация, математические функции.
SciPy: научные вычисления, оптимизация, статистика.
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ данных:
Pandas: работа с табличными данными, DataFrame, Series.
Инструменты для визуализации: Matplotlib, Seaborn, Plotly.
-------------------------------------------------------------------------------------------------------------------------------------------------
Машинное обучение и статистика:
Библиотеки машинного обучения: scikit-learn, TensorFlow, Keras, PyTorch.
Статистические модели и анализ: statsmodels, Dask для обработки больших данных.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
9. Тестирование, отладка и профилирование:
-------------------------------------------------------------------------------------------------------------------------------------------------
Тестирование:
Юнит-тестирование: модули unittest, pytest.
Интеграционное тестирование и TDD.
Инструменты для оценки покрытия кода (coverage.py).
-------------------------------------------------------------------------------------------------------------------------------------------------
Отладка:
Стандартный отладчик pdb (и его расширения ipdb).
Логирование: модуль logging, настройки уровней логов.
-------------------------------------------------------------------------------------------------------------------------------------------------
Профилирование и оптимизация:
Профилировщики: cProfile, line_profiler, memory_profiler.
Инструменты оптимизации: timeit, анализ потребления памяти.
Использование JIT-компиляции (PyPy), Cython, Numba.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
10. Веб-разработка:
-------------------------------------------------------------------------------------------------------------------------------------------------
Фреймворки для создания веб-приложений:
Классические: Django, Flask.
Асинхронные: FastAPI, aiohttp, Tornado.
Дополнительные фреймворки: web2py, Pyramid.
-------------------------------------------------------------------------------------------------------------------------------------------------
REST API и микросервисы:
Создание RESTful API, работа с JSON.
GraphQL, SOAP (если необходимо).
Интеграция с внешними сервисами.
-------------------------------------------------------------------------------------------------------------------------------------------------
Веб-технологии и фронтенд:
Основы HTML, CSS, JavaScript для интеграции с Python-бэкендом.
Шаблонизаторы: Jinja2, Mako.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
11. Интерфейсы и графика:
-------------------------------------------------------------------------------------------------------------------------------------------------
Графические пользовательские интерфейсы (GUI):
Tkinter: стандартный модуль для создания GUI.
PyQt / PySide: интерфейсы с использованием Qt.
Kivy: для создания мульти-тач и кроссплатформенных приложений.
Дополнительные решения: Streamlit, Dash (для веб-интерфейсов).
-------------------------------------------------------------------------------------------------------------------------------------------------
Игровая разработка:
Pygame: разработка 2D-игр.
Другие библиотеки для игр и визуализации.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
12. Работа с базами данных:
-------------------------------------------------------------------------------------------------------------------------------------------------
SQL и реляционные базы данных:
SQLite: работа с локальными базами.
PostgreSQL, MySQL: подключение, драйверы (psycopg2, mysql-connector).
ORM: SQLAlchemy, Django ORM, Peewee.
-------------------------------------------------------------------------------------------------------------------------------------------------
NoSQL базы данных:
Работа с MongoDB (PyMongo).
Другие NoSQL решения (Redis, Cassandra).
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты миграций и администрирования:
Alembic для миграций, администрирование через оболочки.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
13. Оптимизация и производительность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Профилирование и оптимизация кода:
Анализ производительности, оптимизация алгоритмов.
Использование встроенных инструментов (timeit, cProfile).
Применение внешних библиотек: Numba, Cython, PyPy.
-------------------------------------------------------------------------------------------------------------------------------------------------
Управление памятью и сборка мусора:
Тонкости работы сборщика мусора, reference counting.
Модули для мониторинга использования памяти.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
14. Безопасность:
-------------------------------------------------------------------------------------------------------------------------------------------------
Безопасное программирование:
Лучшие практики: валидация данных, защита от SQL-инъекций, обработка исключений.
Безопасность веб-приложений: защита сессий, XSS, CSRF.
-------------------------------------------------------------------------------------------------------------------------------------------------
Криптография и шифрование:
Библиотеки: cryptography, PyCryptodome.
Работа с SSL/TLS, безопасное хранение данных.
-------------------------------------------------------------------------------------------------------------------------------------------------
Аудит и тестирование безопасности:
Инструменты статического и динамического анализа кода.
-------------------------------------------------------------------------------------------------------------------------------------------------
Продвинутые аспекты безопасности:
Помимо базовых мер, можно добавить темы статического и динамического анализа безопасности,
инструменты для поиска уязвимостей и рекомендации по безопасному программированию.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
15. Работа с внешними сервисами и протоколами:
-------------------------------------------------------------------------------------------------------------------------------------------------
HTTP и REST:
Библиотеки для HTTP-запросов: requests, urllib.
Работа с API: RESTful, GraphQL, SOAP.
-------------------------------------------------------------------------------------------------------------------------------------------------
Протоколы и сетевое взаимодействие:
Работа с email (smtplib, email).
FTP, SFTP, WebSocket.
Сетевое программирование: сокеты (модуль socket).
-------------------------------------------------------------------------------------------------------------------------------------------------
Обработка форматов данных:
JSON, XML, CSV: чтение, запись, сериализация и десериализация.
-------------------------------------------------------------------------------------------------------------------------------------------------
Разработка микросервисов и распределённых систем:
Глубокое рассмотрение подходов к созданию микросервисной архитектуры, использование брокеров сообщений (RabbitMQ, Kafka),
а также распределённых вычислительных систем (например, Celery для задач) дополнит понимание масштабируемости приложений.
-------------------------------------------------------------------------------------------------------------------------------------------------
Интеграция с облачными технологиями:
Работа с облачными SDK (например, boto3 для AWS, библиотеки для Google Cloud или Azure) и особенностями развёртывания Python-приложений в облаке.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
16. Разное и дополнительные темы:
-------------------------------------------------------------------------------------------------------------------------------------------------
Работа с датами, временем и локализацией:
Модули: datetime, time, calendar.
Локализация и интернационализация: locale, gettext.
-------------------------------------------------------------------------------------------------------------------------------------------------
Сетевое программирование и системы:
Модуль os: работа с файловой системой, переменные окружения.
Модуль subprocess: выполнение внешних команд.
Автоматизация: скрипты для командной строки, работа с терминалом (argparse, click).
-------------------------------------------------------------------------------------------------------------------------------------------------
Метапрограммирование:
Интроспекция: функции dir(), getattr(), setattr(), isinstance(), issubclass().
Декораторы, метаклассы, модуль inspect.
-------------------------------------------------------------------------------------------------------------------------------------------------
Парадигмы программирования:
Императивное, объектно-ориентированное, функциональное, процедурное.
Аспектно-ориентированное программирование (при необходимости).
-------------------------------------------------------------------------------------------------------------------------------------------------
Сообщество и экосистема:
ПEP-процесс: разработка и обсуждение стандартов.
Конференции, сообщества, открытый исходный код (GitHub, PyPI).
Лицензирование и правовые аспекты.
-------------------------------------------------------------------------------------------------------------------------------------------------
Дизайн-паттерны и архитектурные решения:
Хотя базовые принципы ООП и метапрограммирования включены,
отдельный раздел по дизайн-паттернам (например, Singleton, Factory, Observer, MVC и т.д.) применительно
к Python поможет в построении масштабируемых архитектур.
-------------------------------------------------------------------------------------------------------------------------------------------------
Дополнительные парадигмы и современные архитектуры:
Рассмотрение событийно-ориентированных архитектур, функциональных реактивных подходов и других современных методик разработки,
которые находят применение в Python.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
17. Научные вычисления, анализ данных и машинное обучение:
-------------------------------------------------------------------------------------------------------------------------------------------------
Анализ данных:
Инструменты для работы с большими данными: Dask, PySpark.
Библиотеки визуализации: seaborn, plotly, bokeh.
-------------------------------------------------------------------------------------------------------------------------------------------------
Машинное обучение и искусственный интеллект:
Основные библиотеки: scikit-learn, TensorFlow, Keras, PyTorch.
Специализированные модули для обработки изображений, текста, звука.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
18. Инструменты разработки, тестирования и развёртывания:
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты и среды:
IDE, редакторы кода, Jupyter Notebook/Lab.
Системы контроля версий, интеграция с CI/CD (GitLab CI, GitHub Actions).
Документация, генерация документации (Sphinx, MkDocs).
-------------------------------------------------------------------------------------------------------------------------------------------------
Контейнеризация и виртуализация:
Docker, Kubernetes для развёртывания Python-приложений.
-------------------------------------------------------------------------------------------------------------------------------------------------
Инструменты и практики DevOps для Python:
Включая контейнеризацию (Docker, Kubernetes), системы CI/CD (GitHub Actions, GitLab CI) и автоматизацию развёртывания,
что особенно важно для современных проектов.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

												Встроенные функции Python (built-in functions)
																	abs()											    ████    
																													   ██  ██   
																													  ██    ██  
																													  ████████  
																													  ██    ██  
																													  ██    ██  

Функция abs() используется для возвращения абсолютного значения числа. Это означает,
что она всегда возвращает положительное значение числа, вне зависимости от его знака.

Синтаксис:
abs(x)
где x — число (целое или с плавающей точкой).

Пример:
print(abs(-5))    # 5
print(abs(3.14))  # 3.14
print(abs(0))     # 0

Использование:
Полезно, когда нужно работать с расстоянием или величинами, которые всегда должны быть положительными.

																	aiter()

Функция aiter() используется для получения асинхронного итератора из объекта, который поддерживает асинхронную итерацию.
Это важная функция при работе с асинхронными итераторами, т.е. объектами, которые можно итерировать с использованием await внутри
асинхронных функций.

Синтаксис:
aiter(obj)
где obj — объект, который должен поддерживать асинхронную итерацию (например, асинхронный генератор или объект с методом __aiter__()).

Пример:
import asyncio

# Создадим асинхронный генератор
async def my_async_generator():
    yield 1
    await asyncio.sleep(1)
    yield 2
    await asyncio.sleep(1)
    yield 3

# Получаем асинхронный итератор
async def main():
    async for item in aiter(my_async_generator()):
        print(item)

asyncio.run(main())

Вывод:
1
2
3

Использование:
Обычно aiter() используется для создания асинхронных циклов, например, при обработке потоков данных или работы с асинхронными источниками данных.
"""
Что такое асинхронная итерация?
Когда мы говорим об "иттерации", мы имеем в виду процесс последовательного обхода элементов какого-то объекта (например, списка, кортежа, словаря).
Обычно это делается с помощью цикла for, который берет каждый элемент по очереди и выполняет операцию с ним.

Что такое асинхронная итерация?
В обычной итерации все элементы берутся сразу, один за другим, как в случае с простыми списками.
Но иногда нужно работать с такими объектами, которые не сразу предоставляют элементы (например, данные,
которые загружаются с удаленного сервера или вычисляются по запросу). В этом случае используется асинхронная итерация.

Асинхронная итерация позволяет нам ожидать (то есть использовать await), пока элемент будет готов, и продолжать выполнение программы,
не блокируя её. Это важно для операций, где время отклика неопределенно и мы не хотим, чтобы программа зависала в ожидании.

Что такое асинхронный итератор?
Асинхронный итератор — это объект, который можно перебирать, но для получения следующего элемента нужно
подождать (например, пока данные загрузятся или вычислятся). Этот процесс управления задержками делает итератор "асинхронным".

Чтобы объект стал асинхронным итератором, он должен иметь два метода:
__aiter__() — возвращает сам итератор.
__anext__() — возвращает следующий элемент (с использованием await).

Что делает функция aiter()?
Функция aiter() превращает любой объект, поддерживающий асинхронную итерацию, в асинхронный итератор.
Это нужно, чтобы использовать его в цикле async for, который выполняет асинхронную итерацию.

Пример:
import asyncio

# Асинхронный генератор — это специальная функция, которая генерирует данные с паузами
# чтобы симулировать "долгие" вычисления или получение данных.

async def my_async_generator():
    yield 1  # Возвращаем 1, но до следующего значения будет пауза
    await asyncio.sleep(1)  # Задержка, например, для запроса данных
    yield 2  # Возвращаем 2
    await asyncio.sleep(1)  # Задержка снова
    yield 3  # Возвращаем 3

# Получаем асинхронный итератор с помощью aiter()
async def main():
    # async for — это цикл, который работает с асинхронными итераторами
    async for item in aiter(my_async_generator()):
        print(item)

# Запускаем главный цикл событий
asyncio.run(main())

1) Мы создали асинхронный генератор my_async_generator(), который будет выдавать значения через задержку (с помощью await asyncio.sleep(1)).
2) В функции main() мы используем aiter(), чтобы получить асинхронный итератор из этого генератора.
3) Цикл async for берет элементы по одному и ожидает, пока они будут готовы.
   При этом выполнение не блокируется (то есть другие задачи могут выполняться, пока мы ждем данных).
"""
																	all()

Функция all() проверяет, выполняется ли условие для всех элементов в итерируемом объекте.
Если все элементы истинные (или не нулевые), то возвращается True. Если хотя бы один элемент ложный (или равен False), то возвращается False.

Примеры использования:
values = [True, True, True]
print(all(values))  # Вернёт True, потому что все элементы True

values = [True, False, True]
print(all(values))  # Вернёт False, потому что есть хотя бы один False

numbers = [3, 5, -2, 8]
# Проверяем, что все числа положительные
print(all(n > 0 for n in numbers))  # Вернёт False, потому что есть отрицательное число

Как работает:
В all() мы передаем итерируемый объект (например, список или кортеж)
Если все элементы в этом объекте истинные (т.е. не равны False, пустым строкам, None, числам 0 и т.д.), то вернется True
Если хотя бы один элемент ложный, вернется False

																	any()

Функция any() проверяет, выполняется ли условие хотя бы для одного элемента в итерируемом объекте.
Если хотя бы один элемент истинный, то возвращается True. Если все элементы ложные (или равны False), то возвращается False.

Примеры использования:
values = [False, False, True]
print(any(values))  # Вернёт True, потому что хотя бы один элемент True

values = [False, False, False]
print(any(values))  # Вернёт False, потому что все элементы False

numbers = [3, 5, -2, 8]
# Проверяем, есть ли хотя бы одно положительное число
print(any(n > 0 for n in numbers))  # Вернёт True, потому что есть положительные числа

Как работает:
В any() мы передаем итерируемый объект
Если хотя бы один элемент в объекте истинный, функция вернет True
Если все элементы ложные, вернется False
																	
																	anext()

Функция anext() используется для получения следующего элемента из асинхронного итератора в Python.

Формат вызова:
anext(iterator, default)

iterator — это асинхронный итератор, который должен быть использован в асинхронных функциях или контекстах.
default (опционально) — значение, которое будет возвращено, если итератор завершён.
Если default не указан и итератор завершён, возникает ошибка StopAsyncIteration.

Пример 1: Основное использование
import asyncio
async def count():
    yield 1
    yield 2
    yield 3
async def main():
    counter = count()
    print(await anext(counter))  # 1
    print(await anext(counter))  # 2
    print(await anext(counter))  # 3
asyncio.run(main())

Вывод:
1
2
3

anext() извлекает следующий элемент из асинхронного итератора, и нужно использовать await для асинхронной работы.

Пример 2: Возврат значения по умолчанию
import asyncio
async def count():
    yield 1
    yield 2
async def main():
    counter = count()
    print(await anext(counter, "Конец"))  # 1
    print(await anext(counter, "Конец"))  # 2
    print(await anext(counter, "Конец"))  # Конец
asyncio.run(main())

Вывод:
1
2
Конец

Если итератор завершён, возвращается значение по умолчанию (в данном случае "Конец"), а не возникает ошибка.

Вывод:
anext() используется для получения следующего элемента из асинхронного итератора.
Нужно использовать await для асинхронных операций.
Если итератор завершён, можно указать значение по умолчанию, которое вернётся вместо ошибки.

																	ascii()

Функция ascii() возвращает строковое представление объекта, где все символы,
которые не могут быть отображены как обычные символы в кодировке ASCII, заменяются на соответствующие escape-последовательности.
То есть, эта функция возвращает строку с экранированными символами, которые не входят в стандартный набор ASCII (например, символы юникода).

Пример использования:
text = "Привет, мир!"
print(ascii(text))  # Вернёт 'П\u0440\u0438\u0432\u0435\u0442, \u043c\u0438\u0440!'

# Пример с символами ASCII
text = "Hello!"
print(ascii(text))  # Вернёт 'Hello!'

Как работает:
Функция пытается преобразовать объект в строку.
Если объект состоит из символов, которые входят в стандартный набор ASCII, он возвращает строку без изменений.
Если объект содержит символы, которые не входят в ASCII (например, кириллицу или другие символы юникода),
то они заменяются на escape-последовательности.
Эти последовательности начинаются с символа' \u, за которым идет шестнадцатеричное представление символа.'

Пример:
text = "Python :)"
print(ascii(text))  # Выведет 'Python :)', потому что все символы ASCII

text = "Привет!"  # Содержит русские буквы
print(ascii(text))  # Выведет 'П\u0440\u0438\u0432\u0435\u0442!', потому что русские буквы не входят в ASCII

Зачем это нужно?
Эта функция полезна для вывода строк в стандартной ASCII-форме, например, когда нужно
логировать данные или отправить текст в форматах, поддерживающих только ASCII.
ascii() помогает избежать ошибок, связанных с выводом символов, которые не поддерживаются в кодировке, используемой в приложении или на сервере.

																	bin()											  ██████    
																													  ██    ██  
																													  ██████    
																													  ██    ██  
																													  ██████    

Функция bin() преобразует целое число в строку, представляющую это число в двоичной системе счисления.
Результат всегда начинается с префикса '0b', который указывает на двоичное представление числа.

Пример использования:
num = 10
print(bin(num))  # Выведет '0b1010'

Как работает:
Преобразует целое число в двоичное представление.
Префикс 0b в начале строки указывает, что дальше идет двоичное число.

Пример:
num1 = 5
print(bin(num1))  # '0b101' — двоичное представление числа 5

num2 = 255
print(bin(num2))  # '0b11111111' — двоичное представление числа 255

Зачем это нужно?
Преобразование в двоичную форму полезно при работе с побитовыми операциями,
особенно если нужно визуализировать или манипулировать конкретными битами числа.
Например, можно использовать bin() для того, чтобы показать, как выглядит число в двоичной системе или для создания битовых масок.
"""
Дополнительный пример использования (с побитовыми операциями):
a = 5  # 101 в двоичной системе
b = 3  # 11 в двоичной системе
print(bin(a & b))  # Побитовое "и" (выведет 0b1)
"""
																	bool()

Функция bool() преобразует любой объект в логическое значение True или False.
В Python все значения, которые не являются пустыми или нулевыми (например, непустые строки, списки, числа, отличные от 0),
считаются истинными (True), а пустые или нулевые значения — ложными (False).

Пример использования:
print(bool(0))       # False, так как 0 считается ложным значением
print(bool(42))      # True, любое ненулевое число — истинно
print(bool(""))      # False, пустая строка — ложное значение
print(bool("Hello")) # True, непустая строка — истинно
print(bool([]))      # False, пустой список — ложное значение
print(bool([1, 2]))  # True, непустой список — истинно

Как работает:
Все объекты, которые в Python могут быть приведены к булевому типу, могут быть интерпретированы как True или False.

Примеры ложных значений:
0 (для чисел)
пустые строки ""
пустые коллекции (списки, кортежи, множества, словари)
None
Все остальные значения будут интерпретированы как True.

Когда это полезно?
Используется для проверки истинности или ложности значений.
Например, можно применить bool() при проверке переменной перед выполнением какого-либо кода, чтобы убедиться, что она не пустая или не равна нулю.

user_input = input("Enter a value: ")
if bool(user_input):
    print("You entered:", user_input)
else:
    print("You didn't enter anything.")

    																breakpoint()

Функция breakpoint() используется для установки точки останова в программе, что позволяет тебе приостановить выполнение программы и начать отладку.
Когда Python встречает эту функцию, он автоматически вызывает отладчик, если он установлен в системе.
По умолчанию breakpoint() вызывает встроенный отладчик pdb (Python Debugger),
но ты можешь настроить его на использование другого отладчика, если нужно.

Пример использования:
x = 10
y = 5
breakpoint()  # Программа остановится здесь и запустится отладчик
result = x + y
print(result)

При запуске этого кода программа приостановится на строке breakpoint() и откроется интерактивная сессия отладчика,
где ты сможешь проверить значения переменных, выполнить другие команды и продолжить выполнение программы.

Как работает:
Когда Python встречает breakpoint(), он вызывает отладчик, который позволяет тебе взаимодействовать с кодом во время выполнения.
В отладчике ты можешь использовать команды для выполнения шагов, проверки значений переменных, выхода из программы и т.д.
Например, ты можешь использовать команды типа n (следующий шаг), s (войти в функцию), q (выход из отладчика).

Пример работы с breakpoint():
def add(a, b):
    breakpoint()  # Остановим выполнение функции здесь
    return a + b
result = add(3, 4)
print(result)

Когда программа остановится на breakpoint(), ты можешь проверить значение a, b и другие переменные в контексте выполнения функции.

Когда это полезно?
Используется для отладки кода, когда нужно исследовать текущие значения переменных и поток выполнения программы.
Это упрощает поиск ошибок, потому что позволяет тебе на лету "взглянуть" на состояние программы.

Пример использования отладчика в реальной ситуации:
def find_max(a, b, c):
    breakpoint()  # Остановка для анализа значений
    return max(a, b, c)
print(find_max(2, 8, 5))

Ты можешь использовать отладчик, чтобы увидеть, какие именно значения имеют переменные перед тем, как программа вернёт результат.
"""
n – Переходит к следующей строке в функции.
s – Заходит в функцию, если она вызывается.
c – Продолжает выполнение до следующей точки останова.
q – Выход из отладчика.
l – Показывает код вокруг текущей строки.
p – Печатает значение переменной.
b – Устанавливает точку останова.
tbreak – Устанавливает одноразовую точку останова.
r – Завершает текущую функцию и возвращает управление.
u – Переходит на уровень выше в стеке вызовов.
d – Переходит на уровень ниже в стеке вызовов.
h – Показывает справку по команде.
w – Показывает текущий стек вызовов.
a – Показывает аргументы текущей функции.
"""
																bytearray()	

Функция bytearray() используется для создания изменяемой последовательности байтов.
Она создаёт новый объект bytearray, который является изменяемым аналогом типа bytes.
Это полезно, когда нужно работать с последовательностями байтов, которые можно модифицировать.

Синтаксис:
bytearray([source[, encoding[, errors]]])

Параметры:
source — исходный объект для преобразования в bytearray. Может быть строкой, последовательностью или целым числом.
encoding — (опционально) строка, которая указывает кодировку (если источник — строка).
errors — (опционально) режим обработки ошибок при декодировании.

Примеры использования:

Создание пустого bytearray:
b = bytearray()
print(b)  # bytearray(b'')

Создание bytearray из строки:
b = bytearray("hello", "utf-8")
print(b)  # bytearray(b'hello')

Создание bytearray из списка целых чисел:
b = bytearray([65, 66, 67])
print(b)  # bytearray(b'ABC')

Модификация bytearray:
b = bytearray("hello", "utf-8")
b[0] = 72  # заменяет 'h' на 'H'
print(b)  # bytearray(b'Hello')

Важные моменты:
bytearray можно изменять, в отличие от bytes, который является неизменяемым.
Часто используется для работы с бинарными данными, например, для чтения или записи файлов в бинарном формате.

																bytes()

Функция bytes() создаёт неизменяемую последовательность байтов. Это аналог bytearray(), но неизменяемый.
Он используется, когда необходимо работать с байтами, которые нельзя изменять.
Тип bytes часто используется для представления бинарных данных или для кодирования строк.

Синтаксис:
bytes([source[, encoding[, errors]]])

Параметры:
source — исходный объект, который нужно преобразовать в bytes. Это может быть строка, последовательность чисел или целое число.
encoding — (опционально) кодировка, если исходный объект — строка.
errors — (опционально) режим обработки ошибок при декодировании.

Примеры использования:

Создание пустого объекта bytes:
b = bytes()
print(b)  # b''

Создание bytes из строки с кодировкой:
b = bytes("hello", "utf-8")
print(b)  # b'hello'

Создание bytes из списка целых чисел:
b = bytes([65, 66, 67])
print(b)  # b'ABC'

Создание bytes из числа (повторение байта):
b = bytes(5)  # Создаёт байтовую строку, содержащую 5 нулевых байтов
print(b)  # b'\x00\x00\x00\x00\x00'

Важные моменты:
bytes является неизменяемым, в отличие от bytearray, что означает, что после его создания вы не можете изменять отдельные байты.
bytes удобно использовать для работы с бинарными данными, например, в файлах, сетевых протоколах или для кодирования/декодирования.
bytes() — это хорошая опция, когда данные не нужно изменять и требуется сохранять неизменяемость.

																callable()										             ████████      
																												          ██▓▓░░░░░░▓▓██    
																												        ██░░          ░░██   
																												       ██░░            ░░██  
																												      ██░░              ░░██  
																												      ██░░                    
																												      ██░░                    
																												      ██░░                    
																												      ██░░              ░░██  
																												       ██░░            ░░██  
																												        ██░░          ░░██   
																												          ██▓▓░░░░░░▓▓██    
																												             ████████      

callable() – это встроенная функция, которая проверяет, можно ли вызвать объект как функцию.

Синтаксис:
callable(object)

Параметры:
object — объект, который проверяется на возможность вызова.

Возвращаемое значение:
True, если объект можно вызвать (например, если это функция, метод или объект с методом __call__).
False, если объект нельзя вызвать.

Примеры:
# Пример с функцией
def my_function():
    return "Hello!"
print(callable(my_function))  # True

# Пример с числом
x = 42
print(callable(x))  # False

# Пример с объектом, который имеет метод __call__
class MyClass:
    def __call__(self):
        return "I am callable!"
obj = MyClass()
print(callable(obj))  # True

Объяснение:
callable() полезен, когда нужно проверить, является ли объект функцией или классом с методом __call__(),
чтобы попытаться вызвать его как функцию, не получив ошибку.

																chr()

chr() – функция, которая принимает числовой код символа (из таблицы Unicode) и возвращает сам символ.

Синтаксис:
chr(number)

Параметры:
number — целое число от 0 до 1114111 (диапазон Unicode).

Возвращаемое значение:
Символ, соответствующий переданному числовому коду.

Примеры:
print(chr(65))   # 'A'
print(chr(8364)) # '€'
print(chr(128514)) # '😂'

Объяснение:
chr(65) → символ 'A', так как 65 — это код буквы A в Unicode.
chr(8364) → символ '€' (евро).
chr(128514) → '😂' (эмодзи).
"""
Дополнительно:
Обратная функция — ord(), которая преобразует символ в его числовой код:
print(ord('A'))  # 65
"""
																close()

Функция close() закрывает файлы или ресурсы, которые были открыты в программе.

Где используется?
Закрытие файлов после работы с ними.
Закрытие сетевых соединений.
Закрытие буферов (например, в потоках).

Формат вызова:
файл.close()

Вызывается у объекта, который можно закрыть (например, у файла).

Примеры использования:

Закрытие файла после работы:
file = open("test.txt", "w")  # Открываем файл для записи
file.write("Привет, мир!")  # Записываем текст
file.close()  # Закрываем файл

Проверка, закрыт ли файл:
file = open("test.txt", "r")
print(file.closed)  # False (файл открыт)
file.close()
print(file.closed)  # True (файл закрыт)

Если вызвать close() дважды — ошибки не будет!
file.close()  # Уже закрыт, но ошибки не будет

Автоматическое закрытие (with open)
Лучше всего использовать with open() — он закроет файл сам.
with open("test.txt", "w") as file:
    file.write("Автоматическое закрытие!")
# Файл уже закрыт, даже если программа вылетит с ошибкой.

Что будет, если не закрывать?
Файл может зависнуть в памяти.
Другие программы не смогут его открыть.
Может потеряться часть данных.

																compile()

compile() – функция для компиляции исходного кода Python в объект, который можно выполнить.
Это полезно, когда нужно выполнить строку кода, переданную как текст.

Синтаксис:
compile(source, filename, mode, flags=0, dont_inherit=0)

Параметры:
source — строка с исходным кодом или объект, поддерживающий интерфейс чтения (например, файл).
filename — имя файла (строка), которое будет отображаться в сообщениях об ошибках.
mode — один из трех режимов:
'exec' — компиляция в блок кода (например, несколько выражений).
'eval' — компиляция одного выражения (возвращает результат).
'single' — компиляция одного выражения для интерактивной сессии.
flags — (необязательный) флаги, задающие различные аспекты компиляции.
dont_inherit — (необязательный) если установлен в 1, отказывается от наследования глобальных настроек из окружения.

Возвращаемое значение:
Объект типа code, который можно передать в функцию exec() или eval() для выполнения.

Примеры:

code = 'a = 5\nb = 10\nprint(a + b)'
compiled_code = compile(code, '<string>', 'exec')
exec(compiled_code)  # Вывод: 15

В этом примере строка code компилируется с помощью compile(), а затем выполняется через exec().

expr = '2 + 3'
compiled_expr = compile(expr, '<string>', 'eval')
result = eval(compiled_expr)  # result = 5

Здесь мы компилируем строку как выражение и вычисляем его с помощью eval().

Дополнительно:
Функция compile() часто используется в случае, когда необходимо динамически выполнить код, переданный в виде строки.
"""
Ключевые различия между eval() и compile():

eval():
Это функция, которая выполняет одиночное выражение (например, арифметическое выражение или любую другую логику, которая возвращает значение).
Используется для вычисления значения, возвращаемого выражением. После выполнения ты получаешь результат.

Пример:
result = eval('2 + 2')
print(result)  # 4

В этом примере eval() вычисляет выражение 2 + 2 и возвращает результат.

compile():
Функция compile() используется для создания кода (объекта кода), который можно выполнить позже с помощью функций, как exec() или eval().
Это более универсальный инструмент, который позволяет компилировать не только выражения, но и целые блоки кода, включая многострочные программы.

Пример:
code = '''
def add(x, y):
    return x + y
print(add(3, 4))
'''
compiled_code = compile(code, '<string>', 'exec')
exec(compiled_code)  # Выведет: 7

В этом примере ты передаешь многострочный код в compile(), а затем выполняешь его с помощью exec().
eval() не подходит для такого рода многострочного кода.

Почему использовать compile()?
1) Для многострочного кода. eval() работает только с выражениями (одной строкой), тогда как compile() позволяет компилировать целые блоки кода,
   включая определения функций, классов и т. д.
2) Контроль за исполнением кода. Когда ты компилируешь код с помощью compile(), ты получаешь объект кода,
   который можешь передавать и исполнять позднее. Это полезно, если ты хочешь отложить выполнение кода или контролировать, когда он будет выполнен.

Итог:
Используй eval(), если нужно выполнить простое выражение и получить его результат.
Используй compile(), если нужно составить и исполнить более сложный код, включая многократное выполнение или многострочные блоки.
"""
																complex()

complex() — это встроенная функция, которая используется для создания комплексных чисел в Python.
Комплексное число состоит из двух частей: действительной и мнимой.

Синтаксис:
complex(real, imag)
real — действительная часть (по умолчанию 0).
imag — мнимая часть (по умолчанию 0).

Пример использования:
# Создание комплексного числа
z1 = complex(2, 3)  # 2 + 3j
print(z1)  # (2+3j)

# Комплексное число с нулевой мнимой частью
z2 = complex(4, 0)  # 4 + 0j
print(z2)  # (4+0j)

# Комплексное число с нулевой действительной частью
z3 = complex(0, 5)  # 0 + 5j
print(z3)  # 5j

Что делает:
Функция создает комплексное число, где real — это действительная часть, а imag — мнимая часть.
В Python комплексные числа представляются как числа с суффиксом j для мнимой части. Например, 3 + 4j.

Примечание:
Если передать строку, например, complex("3+4j"), то Python тоже будет интерпретировать это как комплексное число.

Пример:
z = complex("3+4j")
print(z)  # (3+4j)

complex() полезен, когда нужно работать с комплексными числами в математических вычислениях, например, в области численных методов или физики.
"""
Комплексные числа — это числа, которые расширяют обычную систему чисел (вещественные числа), добавляя понятие мнимой части.
Они состоят из двух частей: действительной и мнимой.

Структура комплексного числа:

Комплексное число записывается в виде:
a + bi

a — это действительная часть, которая ведет себя как обычное число (например, 2, -5.6, 3.14).
b — это мнимая часть, которая умножена на мнимую единицу i (в Python её записывают как j).

i (или j в Python) — это мнимая единица, которая определяется свойством:
i² = -1

Математические операции с комплексными числами:
Комплексные числа могут складываться, вычитаться, умножаться и делиться, и все это работает, даже если в результате появляются мнимые числа.

Пример:

Сложение:
(2 + 3j) + (1 + 2j)  # Результат: (3 + 5j)
Складываем действительные части: 2 + 1 = 3, и мнимые: 3j + 2j = 5j.

Вычитание:
(5 + 6j) - (2 + 4j)  # Результат: (3 + 2j)
Вычитаем действительные части: 5 - 2 = 3, и мнимые: 6j - 4j = 2j.

Умножение:
(2 + 3j) * (1 + 2j)  # Результат: (-4 + 7j)
При умножении применяется правило распределения:
(2 + 3j) * (1 + 2j) = 2 * 1 + 2 * 2j + 3j * 1 + 3j * 2j
= 2 + 4j + 3j + 6j²
= 2 + 7j + 6(-1)  # Так как j² = -1
= -4 + 7j

Деление:
(4 + 2j) / (1 + 1j)  # Результат: (3 + 1j)
Чтобы разделить комплексные числа, умножаем числитель и знаменатель на сопряженное число знаменателя (для избавления от мнимой части в знаменателе).

Зачем нужны комплексные числа?
Комплексные числа полезны в ряде областей:
Электротехника — для описания переменных токов, фаз и амплитуд.
Физика — для описания волновых процессов, колебаний и других явлений.
Численные методы — для решения некоторых математических задач, где действительные числа не дают решений.

В Python же работа с комплексными числами значительно упрощена: все стандартные арифметические операции с ними доступны,
и они обрабатываются как единое целое.

Например:
z1 = complex(3, 4)  # Комплексное число: 3 + 4j
z2 = complex(1, 2)  # Комплексное число: 1 + 2j

# Сложение
print(z1 + z2)  # (4 + 6j)

# Умножение
print(z1 * z2)  # (-5 + 10j)

Комплексные числа — это важный инструмент в математике и инженерии, и в Python они используются без лишних сложностей.
"""
																delattr()									      ████████    
																												  ██░░░░░░██  
																												  ██      ░░██  
																												  ██        ██  
																												  ██      ░░██  
																												  ██░░░░░░██  
																												  ████████   

Функция delattr() в Python используется для удаления атрибута объекта.
Она позволяет динамически удалять атрибуты у объектов, а также проверять, существует ли атрибут перед его удалением.
Важным моментом является то, что после удаления атрибута его больше нельзя будет использовать.

Синтаксис:
delattr(object, attribute)
object — это объект, у которого нужно удалить атрибут.
attribute — это строка, представляющая имя атрибута, который нужно удалить.

Пример:
class Car:
    def __init__(self, model, year):
        self.model = model
        self.year = year
car = Car("Toyota", 2020)
print(car.model)  # Вывод: Toyota

# Удаляем атрибут model
delattr(car, 'model')

# Теперь атрибут model удален, и попытка доступа к нему вызовет ошибку
try:
    print(car.model)  # Ошибка: AttributeError
except AttributeError as e:
    print(e)  # Вывод: 'Car' object has no attribute 'model'

Важные моменты:
Ошибка: Если атрибут не существует, delattr() вызывает ошибку AttributeError.
Работает только с аттрибутами: Удалять можно только атрибуты объекта. Например, нельзя удалить метод, если он не является атрибутом.

Почему это полезно?
Удаление атрибутов с помощью delattr() может быть полезно, например,
когда нужно динамически управлять состоянием объекта или избежать лишнего хранения данных.

																dict()

Функция dict() используется для создания словарей в Python. Она позволяет создавать пустой словарь или словарь с заранее заданными данными.

Синтаксис:
dict()  # создаёт пустой словарь
dict(iterable)  # создаёт словарь из итерируемого объекта (например, из списка или кортежа пар ключ-значение)
dict(mapping)  # создаёт словарь из другого словаря или объекта с ключами и значениями
dict(**kwargs)  # создаёт словарь из ключевых словарных пар (ключ=значение)

Примеры использования:

Создание пустого словаря:
my_dict = dict()
print(my_dict)  # Вывод: {}

Создание словаря из списка кортежей (ключ, значение):
pairs = [('name', 'Lollya'), ('age', 30)]
my_dict = dict(pairs)
print(my_dict)  # Вывод: {'name': 'Lollya', 'age': 30}

Создание словаря из других словарей:
other_dict = {'x': 10, 'y': 20}
my_dict = dict(other_dict)
print(my_dict)  # Вывод: {'x': 10, 'y': 20}

Создание словаря с использованием именованных аргументов:
my_dict = dict(name="Lollya", age=30)
print(my_dict)  # Вывод: {'name': 'Lollya', 'age': 30}

Важные моменты:
Параметры в dict() могут быть представлены в различных форматах (списки, кортежи, другие словари, или ключ-значение в виде именованных аргументов).
Словарь хранит неупорядоченные пары ключ-значение.

Почему это полезно?
Использование dict() помогает быстро и гибко создавать словари в различных случаях,
что важно для эффективной работы с данными, например, при обработке и хранении пар ключ-значение.

																dir()

Функция dir() используется для получения списка атрибутов (методов, свойств) объекта или модуля.
В основном, она полезна для того, чтобы посмотреть, что доступно в объекте или в пространстве имён (например, в модуле).

Синтаксис:
dir([object])

Если object не указан, возвращается список атрибутов текущего локального пространства имён.
Если object указан, возвращается список атрибутов объекта, включая его методы и свойства.

Примеры использования:

Без параметра (список атрибутов текущего пространства имён):
print(dir())  # Выведет все доступные имена в текущем пространстве (переменные, функции и т.д.)

С параметром (атрибуты объекта):
x = [1, 2, 3]
print(dir(x))  # Выведет список методов и свойств для списка

Вывод может выглядеть так:
['__add__', '__class__', '__contains__', '__delitem__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

Для модуля:
import math
print(dir(math))  # Выведет список всех функций и констант в модуле math

Вывод будет таким:
['__doc__', '__loader__', '__name__', '__package__', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'comb', ...]

Почему это полезно?
Функция dir() позволяет исследовать объекты и модули, которые могут быть неизвестны или для которых ты хочешь узнать,
какие методы или свойства доступны.
Это особенно полезно при работе с большими библиотеками, когда нужно понять, какие возможности предоставляет объект или модуль.

																divmod()

Функция divmod() принимает два числа и возвращает кортеж, содержащий два значения:
Целочисленное деление (частное)
Остаток от деления (по модулю)

Формат вызова:
divmod(a, b)

где:
a — делимое,
b — делитель.

Пример использования:
result = divmod(10, 3)
print(result)  # Выведет (3, 1)

В этом примере:
10 делим на 3, получаем частное 3 (целочисленное деление),
остаток от деления — 1.

Объяснение:
divmod() не просто выполняет операцию деления, но и возвращает оба значения (целую часть и остаток),
так что в одном вызове сразу получаешь результат двух операций.

Дополнительный пример:
q, r = divmod(29, 5)
print("Частное:", q)  # 5
print("Остаток:", r)   # 4

Итог:
Функция divmod() удобна, когда нужно сразу получить и результат деления, и остаток от него.

																enumerate()										  ████████  
																												  ██        
																												  ██
																												  ██████    
																												  ██
																												  ██        
																												  ████████  

Функция enumerate() используется для получения индекса и элемента в процессе итерации по объектам, таким как списки, кортежи, строки и т. д.
Она возвращает итератор, который генерирует пары: индекс и соответствующий элемент.

Формат вызова:
enumerate(iterable, start=0)

iterable — это объект, который можно итерировать (например, список, строка, кортеж и т. д.).
start — это начальный индекс (по умолчанию он равен 0), с которого будет начинаться нумерация.

Пример использования:
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits):
    print(index, fruit)
Вывод:
0 apple
1 banana
2 cherry

Важно:
enumerate() часто используется, когда нужно не только обрабатывать элементы, но и знать их позицию в коллекции.
Он возвращает пару: сначала индекс элемента, а потом сам элемент.

Пример с заданным начальным индексом:
fruits = ['apple', 'banana', 'cherry']
for index, fruit in enumerate(fruits, start=1):
    print(index, fruit)
Вывод:
1 apple
2 banana
3 cherry

В этом примере индексация начинается с 1, потому что мы передали параметр start=1.

Итог:
enumerate() — это удобный способ получать индекс и элемент одновременно в цикле,
что полезно в разных ситуациях, например, при работе с массивами или списками.

																eval()

Функция eval() выполняет строку как код Python и возвращает результат её выполнения.

Формат вызова:
eval(expression, globals=None, locals=None)

expression — строка с кодом Python.
globals (необязательно) — словарь с глобальными переменными.
locals (необязательно) — словарь с локальными переменными.

Простой пример:
result = eval("2 + 3 * 4")
print(result)  # 14

Строка "2 + 3 * 4" выполняется как обычное выражение Python.

Использование с переменными:
x = 10
y = 5
print(eval("x + y"))  # 15

Здесь eval() использует переменные x и y из текущей области видимости.

Передача словаря globals:
code = "a * b"
values = {"a": 3, "b": 4}
print(eval(code, values))  # 12

Функция eval() использует переменные из переданного словаря.

Опасность eval():
eval() выполняет любой код, переданный в строке, что может привести к уязвимостям!

Пример опасного кода:
evil_code = "import os; os.system('del /S /Q C:\\')"
eval(evil_code)  # Может удалить файлы на Windows!

Поэтому eval() нужно использовать очень осторожно и только с проверенными данными.

Итог:
eval() выполняет строку как код Python.
Может работать с переменными и словарями.
Опасен, если использовать с недоверенными данными.

																exec()

Функция exec() выполняет переданный ей код Python, но в отличие от eval(), она может выполнять несколько строк кода и не возвращает результат.

Формат вызова:
exec(object, globals=None, locals=None)

object — строка с кодом или объект кода (compile()).
globals (необязательно) — словарь глобальных переменных.
locals (необязательно) — словарь локальных переменных.

Простой пример:
code = """
x = 5
y = 10
print(x + y)
"""
exec(code)
# Вывод: 15

Функция exec() выполняет несколько строк кода сразу.

Разница с eval():

eval() возвращает результат выполнения выражения:
print(eval("2 + 3"))  # 5

exec() не возвращает результат, а просто выполняет код:
exec("x = 2 + 3")
print(x)  # 5

Использование exec() с globals и locals:
variables = {"a": 3, "b": 4}
exec("c = a + b", variables)
print(variables["c"])  # 7

Здесь exec() выполняет код в переданном словаре переменных.

Выполнение кода из файла:
with open("script.py", "r") as f:
    exec(f.read())

Функция exec() выполняет содержимое файла как обычный Python-код.

Опасность exec():
Как и eval(), функция exec() выполняет любой переданный код. Это делает её уязвимой для атак, если используется с непроверенными данными.

Например:
user_input = "os.system('rm -rf /')"  # Опасная команда!
exec(user_input)  # Может удалить файлы!

Поэтому exec() нужно использовать только с доверенными источниками.

Итог:
exec() выполняет несколько строк кода.
Не возвращает значение (в отличие от eval()).
Может работать с переменными через globals и locals.
Опасен при работе с непроверенными данными.

																exit()

Функция exit() используется для завершения работы программы в Python.

Формат вызова:
exit([code])

code (необязательный) — код завершения программы.
0 означает успешное завершение.
Любое другое число (например, 1, -1) указывает на ошибку.
Можно передать строку, которая будет выведена перед завершением программы.

Пример 1: Простое завершение программы
print("Программа началась")
exit()
print("Этот текст не выведется")  # Не выполнится

Вывод:
После вызова exit() программа завершается, и код после неё не выполняется.

Пример 2: Завершение с кодом ошибки
exit(1)  # Завершает программу с кодом ошибки 1

В командной строке можно проверить код завершения:
echo $?

Используется, если программа завершилась неудачно.

Пример 3: Завершение с сообщением
exit("Ошибка: файл не найден")

Вывод:
Ошибка: файл не найден

Можно передавать строку, которая будет напечатана перед выходом.

Пример 4: Использование sys.exit()
Функция exit() — это просто удобная обёртка вокруг sys.exit(). Можно импортировать её напрямую:
import sys
sys.exit("Завершение через sys.exit()")

Работает так же, но sys.exit() можно использовать в модулях, тогда как exit() предназначен для интерактивного режима (например, в консоли Python).

Вывод:
exit() завершает выполнение программы.
Можно передать код завершения (0 — успех, 1 — ошибка).
Можно вывести сообщение перед выходом.
Альтернативой является sys.exit(), который предпочтительнее в скриптах.

																Ellipsis (…)

В Python объект Ellipsis (...) — это специальный встроенный объект, который чаще всего используется в срезах, типизации и заполнителях для кода.

Использование в срезах (numpy, pandas):
В многомерных массивах Ellipsis удобно сокращает запись:
import numpy as np
arr = np.arange(27).reshape(3, 3, 3)
print(arr[..., 1])  # Берёт второй столбец всех вложенных массивов

Здесь ... заменяет собой все пропущенные :.

Заполнитель в коде (pass-аналог):
Иногда Ellipsis используют как заглушку вместо pass:
def my_function():
    ...  # Функция пока не реализована

Это аналог pass, но выглядит немного понятнее.

Использование в аннотации типов (Python 3.10+):
Если нужно указать, что функция принимает любые аргументы, Ellipsis можно использовать в Callable:
from typing import Callable
def my_func(callback: Callable[..., int]) -> int:
    return callback(5)

Здесь ... означает, что callback может принимать любые аргументы.

Ellipsis — это объект!
Он существует как отдельный объект:
print(Ellipsis)   # Выведет: Ellipsis
print(type(...))  # <class 'ellipsis'>
print(... is Ellipsis)  # True

Итог:
... — это Ellipsis, встроенный объект Python.
Используется в срезах, типизации, заполнителях кода.
В numpy сокращает сложные индексы.
Может заменять pass.
В typing помогает описывать функции с произвольными аргументами.
"""
В Python есть специальный объект под названием Ellipsis. Он записывается как три точки (...) и выполняет несколько задач.
Это НЕ функция и НЕ оператор, а просто уникальный объект.

Где используется Ellipsis?
В многомерных массивах (например, в numpy):
Если у тебя есть многомерный массив (например, 3D-таблица), то Ellipsis (...) помогает упростить запись срезов.

Пример без ... (обычная запись):
import numpy as np
arr = np.arange(27).reshape(3, 3, 3)  # 3x3x3 массив (трёхмерный)
print(arr[:, :, 1])  # Берём второй столбец из каждого слоя

Пример с ... (короткая запись):
print(arr[..., 1])  # То же самое, но короче

Здесь ... заменяет все пропущенные :.

Как заглушка (pass, но покрасивее)
Когда ты пишешь код, но ещё не придумал реализацию функции или класса, можно использовать ... как заглушку.

Пример:
def my_function():
    ...  # Пока не написал код, но функция есть

class MyClass:
    ...

Это то же самое, что pass, но выглядит проще и понятнее.

Зачем это нужно?
Так код не будет выдавать ошибку, если ты запустишь его до написания логики.

В аннотации типов (поддержка любых аргументов)
Если ты используешь аннотации типов, то ... можно использовать, когда функция принимает любое количество аргументов.

Пример:
from typing import Callable
def execute(func: Callable[..., int]) -> int:
    return func(10)  # Функция принимает любое количество аргументов, но возвращает int

Здесь ... означает, что func может иметь любой набор аргументов.

Ellipsis — это объект Python
Если написать print(...), Python покажет Ellipsis. Это значит, что ... — это реальный объект, встроенный в Python.

Пример:
print(type(...))  # <class 'ellipsis'>
print(... is Ellipsis)  # True

Это подтверждает, что Ellipsis – не просто три точки, а объект со своим классом.

Итог (если коротко):
... (три точки) — это встроенный объект Ellipsis.
Используется в многомерных массивах (numpy) для сокращения записи.
Работает как заглушка, если код ещё не написан.
Применяется в аннотациях типов для функций с любыми аргументами.
Это реальный объект Python, а не просто три точки.

(Ellipsis (...) — это не команда, а просто название объекта в Python.
Ellipsis — это официальное имя для тех самых трёх точек (...), которые можно использовать в коде.
То есть, когда ты пишешь ... (три точки), Python на самом деле воспринимает это как объект Ellipsis.
Так что Ellipsis – это просто название специального встроенного объекта, а сама "команда" – это просто ... (три точки).)
"""
																filter()										  ████████  
																												  ██        
																												  ██        
																												  ██████    
																												  ██        
																												  ██
																												  ██

Фильтрует элементы в последовательности, оставляя только те, которые соответствуют условию.

Формат вызова:
filter(function, iterable)

Как работает:
Берёт функцию, которая возвращает True или False.
Применяет её ко всем элементам последовательности.
Оставляет только те элементы, для которых функция вернула True.

Пример 1: Фильтрация чётных чисел
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # [2, 4, 6]

Здесь lambda x: x % 2 == 0 — это функция, которая проверяет, является ли число чётным.

Пример 2: Удаление пустых строк
words = ["Python", "", "Hello", "", "World"]
filtered = filter(bool, words)
print(list(filtered))  # ['Python', 'Hello', 'World']

Здесь bool автоматически убирает пустые строки, потому что bool("") → False.

Главное про filter():
Используется для фильтрации списков и других коллекций.
Работает быстрее, чем for + if, потому что использует итератор.
Чтобы увидеть результат, нужно преобразовать в list().

																float()

Преобразует число или строку в число с плавающей точкой (дробное число).

Формат вызова (сигнатура функции):
float([x])

Пример 1: Преобразование целых чисел
print(float(5))  # 5.0
print(float(-3))  # -3.0

Пример 2: Преобразование строк
print(float("3.14"))  # 3.14
print(float("2.71e2"))  # 271.0 (экспоненциальная запись)

Если строка не является корректным числом, произойдёт ошибка:
print(float("abc"))  # Ошибка: ValueError

Пример 3: Преобразование bool и None
print(float(True))  # 1.0
print(float(False))  # 0.0
print(float(None))  # Ошибка: TypeError

True превращается в 1.0, False в 0.0, но None нельзя преобразовать.

Пример 4: float() без аргументов
print(float())  # 0.0

Если ничего не передавать, вернётся 0.0.

Главное про float():
Используется для преобразования чисел и строк в дробные числа.
Понимает экспоненциальную запись ("2.71e2" → 271.0).
Если строка не содержит число — ошибка.

																format()

Используется для форматирования чисел и строк по заданному шаблону.

Формат вызова:
format(value, format_spec)

value — значение, которое нужно отформатировать.
format_spec — строка формата (задаёт, как должно выглядеть значение).

Примеры использования:

Округление чисел с плавающей точкой:
print(format(3.14159, ".2f"))  # '3.14' (оставляет 2 знака после точки)
print(format(2.71828, "10.3f"))  # '     2.718' (выравнивание в 10 символов)

Форматирование чисел в разные системы счисления:
print(format(255, "b"))  # '11111111' (двоичное представление)
print(format(255, "x"))  # 'ff' (шестнадцатеричное)

Выравнивание строк:
print(format("Hello", "<10"))  # 'Hello     ' (выравнивание влево)
print(format("Hello", ">10"))  # '     Hello' (выравнивание вправо)
print(format("Hello", "^10"))  # '  Hello   ' (по центру)

Использование в f-строках (Python 3.6+):
num = 3.14159
print(f"{num:.2f}")  # '3.14'

Главное про format():
Позволяет управлять отображением чисел и строк.
Работает как с числами, так и со строками.
Аналогичен .format() у строк и f-строкам.

																frozenset()

frozenset() — это встроенная функция Python, которая возвращает неизменяемое множество.

Неизменяемое множество — это коллекция уникальных элементов, которую нельзя изменять после её создания.
В отличие от обычного множества, где можно добавлять или удалять элементы, в неизменяемом множестве эти операции невозможны.
Например, если вы создадите такое множество, то элементы внутри него останутся постоянными на протяжении всего времени его существования.

В отличие от обычного множества (set), элементы во frozenset нельзя изменять после его создания, то есть нельзя добавлять или удалять элементы.
Однако, элементы внутри такого множества могут быть такими же, как в обычных множествах, то есть изменяемыми типами данных (например, числа, строки).

Формат вызова:
frozenset(iterable)

iterable — это любой итерируемый объект (например, список, строка или множество), из которого будет создано множество frozenset.

Примеры использования:

Создание неизменяемого множества:
frozen = frozenset([1, 2, 3, 4])
print(frozen)  # frozenset({1, 2, 3, 4})

Попытка изменить элементы вызывает ошибку:
frozen = frozenset([1, 2, 3])
# frozen.add(4)  # Ошибка: 'frozenset' object has no attribute 'add'
# frozen.remove(3)  # Ошибка: 'frozenset' object has no attribute 'remove'

frozenset можно использовать как ключ в словаре, в отличие от обычного множества:
my_dict = {}
frozen_set = frozenset([1, 2, 3])
my_dict[frozen_set] = "Значение"
print(my_dict)  # {frozenset({1, 2, 3}): 'Значение'}

Можно создавать frozenset из других коллекций, например, из списка:
frozen = frozenset([1, 2, 3, 2])
print(frozen)  # frozenset({1, 2, 3})

Главное про frozenset():
Используется, когда необходимо создать неизменяемое множество, которое будет использоваться, например, в качестве ключа в словаре.
Не поддерживает операции изменения, такие как добавление или удаление элементов.
Работает быстрее, чем обычное множество для операций, которые не изменяют элементы.

																getattr()										    ██████  
																												  ██        
																												  ██   ███  
																												  ██    ██  
																												    ██████  

Получает значение атрибута (переменной) объекта по его имени в виде строки.

Формат вызова:
getattr(объект, "атрибут" [, значение по умолчанию])

Примеры использования:

Пример 1: Получение существующего атрибута
class Example:
    x = 10
obj = Example()
print(getattr(obj, "x"))  # 10

getattr(obj, "x") эквивалентно obj.x, но работает через строку.

Пример 2: Атрибут отсутствует
print(getattr(obj, "y", "Нет такого"))  # "Нет такого"

Если атрибут "y" не найден, вернётся "Нет такого".
Без значения по умолчанию вызовет ошибку.

Пример 3: Использование с dict
class Example:
    def __init__(self):
        self.data = {"a": 1, "b": 2}
obj = Example()
print(getattr(obj, "data")["a"])  # 1

Когда полезно?
Если нужно динамически получать атрибуты по имени (например, из строки).
Позволяет безопасно обращаться к атрибутам без риска ошибки.

Аналог: obj.x, но getattr() гибче.

																globals()

globals() — это встроенная функция Python, которая возвращает словарь всех глобальных переменных в текущем модуле (файле).

Что такое глобальные переменные?
Глобальные переменные — это переменные, объявленные вне функций и классов. Они доступны во всем коде.

Пример:
x = 10  # Глобальная переменная
def foo():
    print(x)  # Можно использовать x, потому что она глобальная
foo()  # Выведет 10

В отличие от локальных переменных (создаваемых внутри функции), глобальные существуют во всем коде.

globals() в действии

Получение всех глобальных переменных
Функция globals() возвращает словарь всех глобальных переменных, включая переменные, функции и импортированные модули.
x = 42
y = "Привет"
print(globals())  # Выведет большой словарь со всеми глобальными переменными

В выводе будут x, y и даже встроенные объекты, например __name__ и __doc__.

Доступ к переменной через globals()
Можно получать значение переменной через globals()["имя_переменной"]
x = 100
print(globals()["x"])  # 100

Это то же самое, что print(x), но работает динамически.

Изменение глобальной переменной через globals()
Можно менять глобальную переменную так:
x = 5
globals()["x"] = 50  # Изменяем глобальную переменную x
print(x)  # 50

Теперь x хранит 50.

Динамическое создание переменных
Можно создавать новые переменные прямо во время выполнения программы:
globals()["new_var"] = "Я новая переменная"
print(new_var)  # Я новая переменная

Мы добавили переменную без явного объявления.

Разница между globals() и locals()
globals() показывает только глобальные переменные.
locals() показывает переменные внутри функции (локальные).
x = 10  # Глобальная переменная
def test():
    y = 20  # Локальная переменная
    print("locals:", locals())  # Покажет только { "y": 20 }
    print("globals:", globals())  # Покажет все глобальные переменные
test()

Где globals() полезен?
Когда нужно динамически изменять переменные (например, в скриптах).
Для отладки — можно посмотреть все глобальные переменные.
При написании интерпретаторов, компиляторов, отладчиков (например, если нужно выполнить код из строки).

Но использовать globals() нужно осторожно, так как изменение глобальных переменных может усложнить отладку программы.
"""
Разница между global x и globals()["x"]

В Python есть два способа работать с глобальными переменными внутри функции:
Использовать global x
Использовать globals()["x"]

Хотя оба способа позволяют изменять глобальные переменные, у них есть важные различия.
global x — объявление переменной глобальной

Ключевое слово global указывает, что переменная берётся из глобальной области видимости.
x = 10  # Глобальная переменная
def change_x():
    global x  # Говорим, что x — глобальная переменная
    x = 20  # Изменяем её
change_x()
print(x)  # 20

Без global Python бы создал локальную x внутри функции, а не изменил глобальную.

Ограничение: global x можно использовать только внутри функций.

globals()["x"] — доступ к переменной через словарь

Функция globals() возвращает словарь всех глобальных переменных, и мы можем изменять их динамически:
x = 10
def change_x():
    globals()["x"] = 20  # Меняем глобальную переменную через словарь
change_x()
print(x)  # 20

Работает даже без ключевого слова global.

Главное отличие:
способ  			Как работает?							Когда использовать?
global x			Явно указывает, что x глобальная		Когда знаешь имя переменной заранее
globals()["x"]		Доступ к переменной через словарь		Когда имя переменной динамическое

Пример, где globals() полезнее:
var_name = "x"  # Имя переменной как строка
globals()[var_name] = 100  # Меняем x
print(x)  # 100

global x не работает с переменными, чьё имя задано строкой.

Когда лучше использовать?
global x — если работаешь с фиксированными именами переменных.
globals()["x"] — если имя переменной динамическое (например, если оно хранится в строке).

Пример разницы:
x = 5
def test():
    global x  # Указываем, что x глобальная
    x = 10  # Меняем её
    globals()["x"] = 15  # Ещё раз меняем через словарь
test()
print(x)  # 15

global x позволяет изменить переменную только по её имени.
globals()["x"] позволяет работать с динамическими именами.

В большинстве случаев global x предпочтительнее, потому что он более читаемый и безопасный.
"""
																hasattr()										  ██      ██  
																												  ██      ██  
																												  ██      ██  
																												  ██████████  
																												  ██      ██  
																												  ██      ██  
																												  ██      ██  

Функция hasattr(obj, name) проверяет, существует ли у объекта obj атрибут с именем name.
Возвращает True, если атрибут есть, иначе False.

Формат вызова:
hasattr(объект, "имя_атрибута")

объект — любой объект (класс, экземпляр, модуль и т. д.).
"имя_атрибута" — строка с именем атрибута.

Примеры использования:

Проверка наличия атрибута в классе:
class Person:
    age = 25  # У класса есть атрибут age
print(hasattr(Person, "age"))  # True
print(hasattr(Person, "name"))  # False (такого атрибута нет)

Проверка атрибута у объекта:
class Person:
    def __init__(self, name):
        self.name = name  # Атрибут name создаётся в конструкторе
p = Person("Alex")
print(hasattr(p, "name"))  # True (name есть)
print(hasattr(p, "age"))  # False (age не существует)

Проверка наличия метода:
class Test:
    def hello(self):
        print("Привет!")
t = Test()
print(hasattr(t, "hello"))  # True (hello — метод объекта)
print(hasattr(t, "bye"))  # False (bye не существует)

Проверка в модулях:
Можно использовать hasattr() для проверки функций и переменных в импортированном модуле.
import math
print(hasattr(math, "sin"))  # True (функция sin есть)
print(hasattr(math, "unknown"))  # False (такого нет)

Когда использовать?
Если нужно безопасно проверить, есть ли у объекта атрибут, прежде чем к нему обращаться.
В динамических программах, когда имена атрибутов заранее неизвестны.
В модулях и классах для избежания ошибок (AttributeError).

Альтернатива без hasattr()
Если попробовать обратиться к несуществующему атрибуту напрямую, будет ошибка:
p = Person("Alex")
print(p.age)  # Ошибка AttributeError: 'Person' object has no attribute 'age'

Поэтому hasattr() предотвращает такие ошибки, позволяя сначала проверить атрибут.

Пример с обработкой ошибки:
if hasattr(p, "age"):
    print(p.age)  # Только если атрибут есть
else:
    print("Атрибута age нет")

Главное про hasattr()
Проверяет, существует ли атрибут у объекта.
Работает с классами, объектами, модулями.
Помогает избежать ошибок AttributeError.
Возвращает True или False.

																hash()

Функция hash(obj) возвращает хеш-значение объекта. Хеш — это уникальный числовой идентификатор,
который остаётся неизменным для одного и того же объекта (если он неизменяемый).
Используется для быстрого поиска объектов, хранения в множествах (set) и ключах словарей (dict).

Формат вызова:
hash(объект)

объект — любой неизменяемый объект (числа, строки, кортежи и т. д.).

Примеры использования:

Хеширование чисел:
print(hash(10))  # Например, 10
print(hash(-5))  # Например, -5

Хеш чисел совпадает с их значением.

Хеширование строк:
print(hash("Привет"))  # Например, -734562738945021
print(hash("Python"))  # Например, 53489765348132

Хеш строк зависит от их содержимого.

Хеширование кортежей:
print(hash((1, 2, 3)))  # Например, 2528502973977326415

Кортежи хешируются, если их элементы неизменяемые.

Ошибка с изменяемыми объектами:
print(hash([1, 2, 3]))  # Ошибка TypeError
print(hash({1, 2, 3}))  # Ошибка TypeError

Списки (list), множества (set), словари (dict) нельзя хешировать, так как они изменяемые.

Где применяется hash()?
Для работы с set и dict

Хешируемые объекты могут быть ключами в dict или элементами set:
data = {("apple", "red"): 10, ("banana", "yellow"): 5}  # Кортежи можно использовать как ключи
print(data[("apple", "red")])  # 10

Для быстрого сравнения объектов
Хеширование ускоряет поиск и сравнение данных.

Главное про hash()
Возвращает уникальный числовой хеш объекта.
Работает только с неизменяемыми объектами (числа, строки, кортежи).
Используется в set и dict для быстрого поиска.
Хешируемые объекты остаются неизменными, иначе их хеш изменится.

																help()

Функция help() отображает справочную информацию о любом объекте, модуле или функции в Python.
Используется для быстрого просмотра документации без выхода из интерпретатора.

Формат вызова:
help(объект)

объект — любой модуль, функция, класс или переменная.
Если вызвать help() без аргументов, откроется интерактивная справочная система.

Примеры использования:

Общая справка:
help()  # Открывает встроенную справку (выход: q)

Справка по функции:
help(len) 

Выведет документацию функции len().

Справка по модулю:
import math
help(math)

Покажет всё содержимое модуля math.

Справка по классу:
help(dict)

Опишет работу словаря.

Справка по методу объекта:
help(str.upper)

Выведет информацию о методе upper() строки.

Главное про help()
Показывает документацию для функций, классов, модулей.
Можно вызывать без аргументов для интерактивного режима.
Полезно для быстрого ознакомления с функциями без Google.

																hex()

Функция hex() преобразует число в шестнадцатеричную (hex) систему.

Формат вызова:
hex(x)

x — целое число (int).
Возвращает строку в формате 0x....

Примеры использования:

Преобразование целых чисел:
print(hex(255))  # 0xff
print(hex(16))   # 0x10
print(hex(-42))  # -0x2a

Число переводится в hex и дополняется префиксом 0x.

Преобразование через int:
print(int("0xff", 16))  # 255

Обратно в десятичную систему.

Применение с bin(), oct():
x = 42
print(bin(x))  # 0b101010  (двоичная)
print(oct(x))  # 0o52      (восьмеричная)
print(hex(x))  # 0x2a      (шестнадцатеричная)

Главное про hex()
Преобразует число в шестнадцатеричную систему.
Возвращает строку вида 0x....
Поддерживает отрицательные числа.
Работает только с целыми числами (int).

																id()											  ██████████  
																												      ██      
																												      ██      
																												      ██      
																												      ██      
																												      ██      
																												  ██████████  

Функция id() возвращает уникальный идентификатор объекта в памяти.

Формат вызова:
id(object)

object — любой объект (число, строка, список, словарь и т. д.).
Возвращает уникальный номер, который сохраняется, пока объект существует.

Примеры использования:
Уникальный идентификатор объекта:
a = 42
b = 42
print(id(a))  # Например, 140721935104144
print(id(b))  # То же самое, если число неизменяемое

В Python числа кэшируются, поэтому id(a) == id(b).

Идентификаторы изменяемых объектов:
x = [1, 2, 3]
y = [1, 2, 3]
print(id(x))  # Например, 140721935204416
print(id(y))  # Другое значение, так как `x` и `y` — разные списки

Списки, словари и другие изменяемые объекты создаются заново, у них разные id.

Проверка одной и той же ссылки:
z = x
print(id(x) == id(z))  # True — это один и тот же объект

z ссылается на x, их id() одинаковые.

Главное про id()
Возвращает уникальный номер объекта в памяти.
Для неизменяемых объектов (int, str, tuple) id() может быть одинаковым.
Изменяемые объекты (list, dict, set) имеют разные id, даже если их содержимое одинаковое.

																input()
																
Функция input() запрашивает ввод данных от пользователя в виде строки.

Формат вызова
input(prompt)

prompt — (необязательный) текст, который будет выведен на экране перед тем, как программа запросит ввод от пользователя.

Примеры использования:

Простой ввод:
name = input("Введите ваше имя: ")
print("Привет, " + name + "!")

Функция выведет запрос на ввод, и когда пользователь введёт текст (например, "Лолита"), программа выведет:
Привет, Лолита!

Ввод числа (с преобразованием типа):
age = input("Сколько вам лет? ")
age = int(age)  # Преобразуем строку в целое число
print(f"Вам {age} лет.")

Важно, что input() всегда возвращает строку, даже если введено число.
Поэтому, если нужно работать с числовыми значениями, их нужно преобразовывать.

Ввод нескольких значений (через разделитель):
values = input("Введите несколько чисел через пробел: ")
numbers = list(map(int, values.split()))  # Разделяем строку и преобразуем элементы в числа
print(numbers)

В этом примере мы получаем строку, разбиваем её по пробелам и превращаем каждый элемент в целое число.

Главное про input()
Функция всегда возвращает строку (даже если ввод — число).
Можно использовать параметр prompt, чтобы вывести подсказку перед запросом.
Для работы с числами нужно преобразовывать ввод в нужный тип данных (например, с помощью int() или float()).

																int()

Команда int() используется для преобразования значений в целое число (тип данных int).

Синтаксис:
int(x, base=10)

x — объект, который мы хотим преобразовать в целое число. Может быть строкой, числом с плавающей точкой или другим числовым объектом.
base — основание системы счисления (по умолчанию 10, но можно использовать и другие системы счисления, например, для двоичных чисел).

Примеры:

Преобразование строки в целое число:
print(int("10"))  # 10
print(int("-5"))   # -5
print(int("3.14")) # 3 (десятичная часть отбрасывается)

Преобразование с указанием системы счисления:
print(int("1010", 2))  # 10 (двоичное число)
print(int("A", 16))    # 10 (шестнадцатиричное число)

base определяет систему счисления для строки.

Преобразование вещественного числа в целое:
print(int(3.99))  # 3 (дробная часть отброшена)

Пример с ошибкой:
print(int("abc"))  # Ошибка: ValueError

Преобразование из булевых значений:
print(int(True))   # 1
print(int(False))  # 0

True превращается в 1, а False в 0.

Преобразование с отрицательным числом:
print(int("-100")) # -100

Ключевые моменты:
Если строка не является числом, возникает ошибка ValueError.
При преобразовании вещественного числа в целое, дробная часть отбрасывается.
Для строк, представляющих числа в других системах счисления (например, двоичном или шестнадцатиричном),
можно указать основание с помощью параметра base.
В общем, int() — это удобная функция для работы с целыми числами и для преобразования строк в числа разных систем счисления.

																isinstance()

Функция isinstance() используется для проверки, является ли объект экземпляром определённого класса или подкласса.
Это полезно, когда нужно проверить тип объекта, особенно при работе с наследованием или полиморфизмом.

Синтаксис:
isinstance(object, classinfo)

object — это объект, который мы проверяем.
classinfo — это класс или кортеж классов, которые мы проверяем на соответствие объекту.

Примеры:

Проверка типа объекта:
print(isinstance(5, int))      # True (5 - это целое число)
print(isinstance("hello", str)) # True ("hello" - строка)
print(isinstance(3.14, float))  # True (3.14 - число с плавающей точкой)
print(isinstance([1, 2, 3], list)) # True (список)

Проверка с несколькими типами: Можно передавать кортеж классов, чтобы проверить, принадлежит ли объект к одному из них.
print(isinstance(5, (int, float))) # True (5 - это int)
print(isinstance(3.14, (int, float))) # True (3.14 - это float)
print(isinstance("hello", (int, float))) # False (строка не int или float)

Проверка объекта с наследованием: Если класс наследуется от другого, isinstance() также проверит это.
class Animal:
    pass
class Dog(Animal):
    pass
dog = Dog()
print(isinstance(dog, Dog))   # True (dog является экземпляром Dog)
print(isinstance(dog, Animal)) # True (dog также является экземпляром Animal, так как Dog наследует Animal)

Сложные примеры с комбинированными типами: Проверка объекта на принадлежность к типу,
который является частью большого класса или родительского класса:
class A:
    pass
class B(A):
    pass
obj = B()
print(isinstance(obj, A))  # True, так как B наследует A
print(isinstance(obj, B))  # True, так как obj это экземпляр B
print(isinstance(obj, object))  # True, так как все объекты наследуют от object

Ключевые моменты:
isinstance() помогает избежать ошибок типов, проверяя объект перед его использованием.
Может проверять объект на соответствие нескольким типам сразу.
Также работает с наследованием, проверяя, является ли объект экземпляром класса или его подклассов.

																issubclass()

Функция issubclass() используется для проверки, является ли класс подклассом другого класса.
Это особенно полезно при работе с наследованием, когда нужно проверить, наследует ли один класс от другого.

Синтаксис:
issubclass(class, classinfo)

class — это класс, который проверяется.
classinfo — это класс или кортеж классов, с которыми нужно проверить наследование.

Примеры:

Проверка подкласса:
class Animal:
    pass
class Dog(Animal):
    pass
print(issubclass(Dog, Animal))  # True (Dog — подкласс Animal)
print(issubclass(Animal, Dog))  # False (Animal не является подклассом Dog)

Проверка с несколькими классами: Вы можете передать кортеж классов, чтобы проверить, является ли класс подклассом любого из них.
class Animal:
    pass
class Dog(Animal):
    pass
class Cat(Animal):
    pass
print(issubclass(Dog, (Animal, Cat)))  # True (Dog — подкласс Animal)
print(issubclass(Cat, (Dog, Animal)))  # True (Cat — подкласс Animal)

Работа с несколькими уровнями наследования: Проверка работы с классами на более глубоком уровне наследования:
class Animal:
    pass
class Mammal(Animal):
    pass
class Dog(Mammal):
    pass
print(issubclass(Dog, Mammal))  # True (Dog — подкласс Mammal)
print(issubclass(Dog, Animal))  # True (Dog — подкласс Animal через Mammal)
print(issubclass(Mammal, Animal))  # True (Mammal — подкласс Animal)

Проверка с базовым классом object: Все классы в Python автоматически наследуют от базового класса object.
class MyClass:
    pass
print(issubclass(MyClass, object))  # True (все классы в Python наследуют от object)

Проверка на исключения: Пример с использованием исключений:
class MyError(Exception):
    pass
class FileError(MyError):
    pass
print(issubclass(FileError, MyError))  # True (FileError — подкласс MyError)
print(issubclass(MyError, FileError))  # False (MyError не является подклассом FileError)

Ключевые моменты:
issubclass() проверяет, является ли один класс подклассом другого.
Может проверять несколько классов сразу, передав кортеж классов.
Учитывает все уровни наследования, то есть даже если класс наследует от другого через несколько промежуточных классов, это всё будет учтено.
Подходит для работы с исключениями, интерфейсами и проверкой иерархий классов в объектно-ориентированном программировании.

																iter()

Функция iter() используется для получения итератора из объекта, который поддерживает протокол итерируемости.
То есть она превращает любой итерируемый объект (например, список, строку или множество) в итератор,
с помощью которого можно проходить по его элементам.

Синтаксис:
iter(object)

object — объект, который должен поддерживать протокол итерируемости (например, список, строка, кортеж, множество и т. д.).

Пример использования:

Простой пример с последовательностью:
lst = [1, 2, 3]
it = iter(lst)  # Преобразуем список в итератор
print(next(it))  # 1
print(next(it))  # 2
print(next(it))  # 3
# Если вызвать next(it) снова, то будет ошибка StopIteration

Использование в цикле: Функция iter() часто используется внутри циклов for,
так как цикл for сам автоматически вызывает iter() на итерируемых объектах.
lst = [1, 2, 3]
for i in iter(lst):  # Этот код эквивалентен просто for i in lst:
    print(i)

Итератор для строки:
s = "hello"
it = iter(s)  # Преобразуем строку в итератор
print(next(it))  # h
print(next(it))  # e

Использование с next(): Итератор позволяет поочередно получать элементы коллекции с помощью функции next():
my_list = [10, 20, 30]
iterator = iter(my_list)
print(next(iterator))  # 10
print(next(iterator))  # 20
print(next(iterator))  # 30
# Если вызвать next() снова, будет выброшено исключение StopIteration

Примечания:
Итераторы — это объекты, которые поддерживают методы __iter__() и __next__().
Как только итератор дойдет до конца коллекции, следующая попытка вызова next() выбросит исключение StopIteration,
что является сигналом для завершения итерации.
Итератор позволяет работать с коллекциями по одному элементу за раз, экономя память, так как не нужно загружать всю коллекцию в память сразу.

Итератор и for:

Циклы for автоматически используют iter(). Так что, когда мы пишем:
for item in some_collection:
    print(item)

Python фактически вызывает iter(some_collection) и продолжает итерацию до тех пор, пока не будет достигнут конец коллекции.

Особенности:
Если объект не является итерируемым, то при попытке передать его в iter() будет выброшено исключение TypeError.
Например, целые числа или другие неитерируемые объекты не могут быть преобразованы в итератор с помощью iter().

																len()											  ██          
																												  ██          
																												  ██          
																												  ██          
																												  ██          
																												  ██░░░░░░    
																												  ██████████  

Функция len() используется для получения длины (количества элементов) объекта.
Это может быть длина строки, списка, кортежа, множества или других объектов, которые поддерживают протокол измерения длины.

Синтаксис:
len(object)

object — объект, длину которого мы хотим узнать. Он должен поддерживать метод __len__(),
что характерно для итерируемых объектов, таких как строки, списки, кортежи, множества и т. д.

Примеры использования:

Длина строки:
s = "Hello, world!"
print(len(s))  # 13

Длина списка:
lst = [1, 2, 3, 4, 5]
print(len(lst))  # 5

Длина кортежа:
t = (1, 2, 3)
print(len(t))  # 3

Длина множества:
my_set = {1, 2, 3, 4}
print(len(my_set))  # 4

Длина словаря: Для словаря len() возвращает количество ключей:
my_dict = {"a": 1, "b": 2, "c": 3}
print(len(my_dict))  # 3

Длина пустого объекта: Если объект пустой, len() вернет 0:
empty_list = []
print(len(empty_list))  # 0

Ошибка при использовании с неподдерживаемыми объектами: Если объект не поддерживает протокол длины, например,
целое число, будет выброшено исключение:
num = 10
print(len(num))  # TypeError: object of type 'int' has no len()

Примечания:
Функция len() возвращает целое число, представляющее количество элементов в объекте.
Она работает только с объектами, которые поддерживают метод __len__(). Это важно,
поскольку не все объекты в Python имеют длину (например, числовые типы).
Очень часто len() используется для проверки пустоты объекта: если len(obj) == 0, то объект пуст.

Применение:
Циклы: Например, в цикле можно использовать len() для ограничения количества итераций.
Проверка пустоты: Вместо того чтобы проверять if len(obj) == 0, можно использовать конструкцию if not obj, которая вернет True, если объект пуст.
Обработка данных: В задачах, где нужно обработать коллекцию данных, len() поможет узнать количество элементов и определить дальнейшие действия.
В целом, len() является одной из самых часто используемых функций для работы с итерируемыми объектами в Python.

																list()

Функция list() используется для создания нового списка в Python.
Она может преобразовать другие итерируемые объекты (строки, кортежи, множества и т. д.) в список.

Синтаксис:
list([iterable])

iterable — объект, который можно итерировать, такой как строка, кортеж, множество или другой список.
Этот аргумент является необязательным, если его не передать, будет создан пустой список.

Примеры использования:

Преобразование строки в список:
s = "hello"
result = list(s)
print(result)  # ['h', 'e', 'l', 'l', 'o']

Преобразование кортежа в список:
t = (1, 2, 3, 4)
result = list(t)
print(result)  # [1, 2, 3, 4]

Преобразование множества в список:
my_set = {1, 2, 3}
result = list(my_set)
print(result)  # [1, 2, 3] (порядок может изменяться, так как множества неупорядочены)

Создание пустого списка: Если передать пустой аргумент или ничего не передавать, будет создан пустой список:
empty_list = list()
print(empty_list)  # []

Преобразование словаря в список: Когда передаете словарь в list(), он преобразует его в список ключей:
my_dict = {"a": 1, "b": 2}
result = list(my_dict)
print(result)  # ['a', 'b']

Преобразование диапазона в список: Преобразование объекта range (диапазона чисел) в список:
range_obj = range(5)
result = list(range_obj)
print(result)  # [0, 1, 2, 3, 4]

Создание списка из чисел с условием (например, с использованием генераторов):
result = list(i * 2 for i in range(5))
print(result)  # [0, 2, 4, 6, 8]

Примечания:
list() позволяет создавать новые списки и преобразовывать другие итерируемые объекты (например, строки, множества, кортежи) в списки.
Это может быть полезно, если нужно изменить порядок элементов или если
нужно использовать возможности списка (например, добавление элементов через append(), удаление через remove() и так далее).

Если объект уже является списком, то list() создаст его копию:
original_list = [1, 2, 3]
copy_list = list(original_list)
print(copy_list)  # [1, 2, 3]

Применение:
Преобразование строк и других итерируемых объектов в списки.
Создание нового списка на основе других коллекций.
Использование с диапазонами чисел, если нужно собрать все числа в список для дальнейшей обработки.
list() — это полезная функция, которая широко применяется для работы с коллекциями в Python.

																locals()

Функция locals() в Python используется для получения словаря,
который содержит текущие локальные символы (переменные, функции и их значения) в области видимости, где эта функция была вызвана.
Этот словарь отражает локальное пространство имён, то есть переменные, определённые в текущей функции или методе.

Синтаксис:
locals()

Как работает:
Когда вызывается без аргументов, locals() возвращает словарь, в котором ключами являются имена локальных переменных, а значениями — их значения.
В отличие от globals(), который возвращает глобальное пространство имён, locals() работает с локальной областью видимости.

Пример 1: Локальные переменные внутри функции
def example_function():
    x = 10
    y = 20
    print(locals())  # {'x': 10, 'y': 20}
example_function()

Внутри функции example_function мы создаём локальные переменные x и y, а затем вызываем locals(), чтобы вывести словарь этих переменных.

Пример 2: Изменение локальных переменных через locals()
def example_function():
    x = 10
    y = 20
    locs = locals()
    locs['x'] = 100  # Изменяем значение переменной x через словарь
    print(x)  # 100 (переменная x была изменена)
    print(locs)  # {'x': 100, 'y': 20}
example_function()

Внутри функции мы изменяем значение переменной x, обратившись к словарю, возвращённому функцией locals().
Это изменение отразится на значении самой переменной.

Пример 3: В глобальной области видимости
Когда вызывается locals() в глобальной области видимости (например, на уровне модуля), результат будет такой же, как и у globals():
a = 5
b = 10
print(locals())  # {'a': 5, 'b': 10}

Примечания:
Не всегда изменения через locals() в глобальном контексте будут работать.
Изменение значений в словаре, возвращённом locals(), может не повлиять на глобальные переменные,
так как для глобальных переменных используется globals():
x = 5
locs = locals()
locs['x'] = 100  # Это не изменит глобальную переменную x
print(x)  # 5

Для модификации глобальных переменных нужно использовать globals():
x = 5
globs = globals()
globs['x'] = 100  # Теперь переменная x будет изменена в глобальной области видимости
print(x)  # 100

Применение:
locals() полезен для отладки и анализа текущего состояния локальных переменных в функциях.
Иногда используется для динамического создания переменных или для анализа текущего контекста в сложных функциях или классах.
Важно:
Локальная область видимости — это область видимости, которая определяется внутри функций или методов.
Важно понимать, что изменения через locals() не всегда будут работать одинаково в глобальном и локальном контексте.

																map()											  ██        ██  
																												  ███      ███  
																												  ██ █    █ ██  
																												  ██  █  █  ██  
																												  ██   ██   ██  
																												  ██        ██  
																												  ██        ██  

Функция map() в Python используется для применения заданной функции к каждому элементу
итерируемого объекта (например, списка, множества, кортежа и т. д.) и возвращает итератор с результатами применения функции.

Синтаксис:
map(function, iterable, ...)

function — это функция, которая будет применяться к каждому элементу итерируемого объекта.
iterable — итерируемый объект (например, список, кортеж и т. д.), элементы которого будут переданы функции.
Могут быть переданы дополнительные итерируемые объекты (необязательно), и функция будет применяться поэлементно к каждому из них.

Пример 1: Применение функции ко всем элементам списка
Допустим, у нас есть список чисел, и мы хотим применить функцию, которая умножает каждое число на 2:
numbers = [1, 2, 3, 4, 5]
# Функция, умножающая число на 2
def multiply_by_two(x):
    return x * 2
result = map(multiply_by_two, numbers)
print(list(result))  # [2, 4, 6, 8, 10]

В этом примере map применяет функцию multiply_by_two ко всем элементам списка numbers, возвращая итератор, который мы преобразуем в список.

Пример 2: Использование lambda-функции
Для простоты можно использовать лямбда-функции (анонимные функции) прямо в вызове map():
numbers = [1, 2, 3, 4, 5]
# Умножаем каждый элемент на 2 с помощью lambda
result = map(lambda x: x * 2, numbers)
print(list(result))  # [2, 4, 6, 8, 10]

Пример 3: Передача нескольких итерируемых объектов
Если передать несколько итерируемых объектов, функция будет применяться поэлементно ко всем этим объектам.
Важно, чтобы все итерируемые объекты имели одинаковую длину, иначе map() завершится, когда закончится самый короткий из них.
list1 = [1, 2, 3]
list2 = [4, 5, 6]
# Функция, которая складывает два числа
def add(x, y):
    return x + y
result = map(add, list1, list2)
print(list(result))  # [5, 7, 9]

Пример 4: Преобразование строк в целые числа
Допустим, у нас есть список строк, представляющих числа, и мы хотим преобразовать их в целые числа:
str_numbers = ['1', '2', '3', '4']
# Преобразуем строки в числа
result = map(int, str_numbers)
print(list(result))  # [1, 2, 3, 4]

Примечания:
Возвращаемое значение: map() возвращает итератор, а не список.
Если нужно получить все элементы сразу, их нужно привести к списку или использовать в цикле:
result = map(int, str_numbers)
for num in result:
    print(num)

Отложенное выполнение: Поскольку map() возвращает итератор, вычисления выполняются "по требованию",
что позволяет экономить память, особенно для больших данных.

Применение в реальной жизни:
map() полезен при необходимости применять одну и ту же операцию ко всем элементам коллекции.
Используется для улучшения читаемости кода в случаях, когда нужно выполнить однообразную операцию на всех элементах последовательности.

Преимущества:
Позволяет быстро и эффективно обрабатывать коллекции данных.
Может быть использован для преобразования элементов в различные типы или выполнения других операций.

																max()

Функция max() в Python используется для нахождения наибольшего элемента из переданных аргументов или в итерируемом объекте.

Синтаксис:
max(iterable, *[, key, default])
max(arg1, arg2, *args[, key])

Если передан итерируемый объект (например, список, кортеж, множество), функция вернёт наибольший элемент.
Если передано несколько аргументов, функция вернёт наибольший среди них.
key (необязательно) — функция, которая будет применяться к элементам перед сравнением.
default (необязательно) — значение, которое возвращается, если итерируемый объект пуст (используется только с iterable).

Примеры:
Поиск максимального значения в списке
numbers = [3, 8, 1, 6, 10, 2]
print(max(numbers))  # 10

Поиск среди нескольких значений:
print(max(3, 8, 1, 6, 10, 2))  # 10

Использование key: поиск самой длинной строки
words = ["яблоко", "банан", "киви", "ананас"]
print(max(words, key=len))  # "ананас" (самая длинная строка)

Поиск по вложенным структурам (например, по второму элементу кортежа):
pairs = [(1, 3), (2, 8), (5, 2)]
print(max(pairs, key=lambda x: x[1]))  # (2, 8) (с наибольшим вторым элементом)

Использование default при пустом списке:
empty_list = []
print(max(empty_list, default="Нет значений"))  # "Нет значений"

Поиск максимального символа в строке (по ASCII-коду):
print(max("hello"))  # "o" (т.к. 'o' имеет самый высокий ASCII-код)

Полезные моменты:
Работает как с числами, так и со строками, кортежами и списками.
Можно использовать параметр key, если нужно сравнивать по особым критериям.
default спасает от ошибки ValueError, если итерируемый объект пуст.

																min()

Функция min() в Python используется для нахождения наименьшего элемента из переданных аргументов или в итерируемом объекте.

Синтаксис:
min(iterable, *[, key, default])
min(arg1, arg2, *args[, key])

Если передан итерируемый объект (список, кортеж, множество), функция вернёт наименьший элемент.
Если передано несколько аргументов, функция вернёт наименьший среди них.
key (необязательно) — функция, которая будет применяться к элементам перед сравнением.
default (необязательно) — значение, которое возвращается, если итерируемый объект пуст (работает только с iterable).

Примеры:

Поиск минимального значения в списке:
numbers = [3, 8, 1, 6, 10, 2]
print(min(numbers))  # 1

Поиск среди нескольких значений:
print(min(3, 8, 1, 6, 10, 2))  # 1

Использование key: поиск самой короткой строки:
words = ["яблоко", "банан", "киви", "ананас"]
print(min(words, key=len))  # "киви" (самая короткая строка)

Поиск по вложенным структурам (например, по второму элементу кортежа):
pairs = [(1, 3), (2, 8), (5, 2)]
print(min(pairs, key=lambda x: x[1]))  # (5, 2) (с наименьшим вторым элементом)

Использование default при пустом списке:
empty_list = []
print(min(empty_list, default="Нет значений"))  # "Нет значений"

Поиск минимального символа в строке (по ASCII-коду):
print(min("hello"))  # "e" (т.к. 'e' имеет самый низкий ASCII-код)

Полезные моменты:
Работает с числами, строками, кортежами и списками.
Можно использовать параметр key, если нужно сравнивать по особым критериям.
default спасает от ошибки ValueError, если итерируемый объект пуст.

																memoryview()

Функция memoryview() создаёт представление (view) в памяти без копирования данных.
Используется для работы с байтовыми объектами (bytes, bytearray) без лишних затрат памяти.

Синтаксис:
memoryview(obj)

obj — объект, который поддерживает интерфейс буфера (например, bytes, bytearray).

Примеры:

Создание memoryview из bytes:
data = bytes([10, 20, 30, 40, 50])
mv = memoryview(data)
print(mv[0])  # 10 (первый байт)
print(mv.tolist())  # [10, 20, 30, 40, 50] (преобразование в список)

memoryview из bytearray (изменяемый):
data = bytearray([1, 2, 3, 4, 5])
mv = memoryview(data)
mv[0] = 100  # Изменяем первый байт
print(data)  # bytearray(b'd\x02\x03\x04\x05')

Доступ к срезам:
data = bytearray([10, 20, 30, 40, 50])
mv = memoryview(data)
print(mv[1:4].tolist())  # [20, 30, 40]

Формат и размер (format, nbytes):
print(mv.format)  # 'B' (unsigned byte)
print(mv.nbytes)  # 5 (всего байт)

Полезные моменты:
Работает без копирования, экономя память.
Можно изменять bytearray через memoryview.
Можно работать с частями данных без создания новых объектов.
Используется в работе с файлами, сокетами и бинарными протоколами.

																next()											  ██      ██  
																												  ███     ██  
																												  ██ ██   ██  
																												  ██  ██  ██  
																												  ██   ██ ██  
																												  ██    ████  
																												  ██      ██  

Функция next() используется для получения следующего элемента из итератора.

Синтаксис:
next(iterator[, default])

iterator — любой итерируемый объект (например, генератор, список, iter()).
default (необязательно) — значение, которое вернётся, если элементы закончились (иначе будет StopIteration).

Примеры:

Получение следующего элемента:
it = iter([10, 20, 30])
print(next(it))  # 10
print(next(it))  # 20
print(next(it))  # 30
print(next(it))  # Ошибка StopIteration!

Использование default, чтобы избежать ошибки:
it = iter([1, 2])
print(next(it, "Конец"))  # 1
print(next(it, "Конец"))  # 2
print(next(it, "Конец"))  # "Конец"

next() + генератор:
def numbers():
    yield 100
    yield 200
    yield 300
gen = numbers()
print(next(gen))  # 100
print(next(gen))  # 200
print(next(gen))  # 300
print(next(gen, "Конец"))  # "Конец"

Полезные моменты:
Работает с любыми итераторами.
Позволяет постепенно перебирать элементы без циклов.
default избегает ошибки StopIteration.
Полезен при работе с генераторами и потоками данных.
"""
Когда процесс next() сбивается и как его сбросить?

Функция next() работает с итераторами, которые не могут автоматически вернуться в начало.
Если next() дошёл до конца — дальнейшие вызовы вызывают ошибку StopIteration, и итератор становится бесполезным.

Как сбросить next() и начать заново?
Итераторы не обнуляются автоматически!

Но есть несколько способов их перезапустить:

Создать новый итератор (самый простой способ):
lst = [1, 2, 3]
it = iter(lst)  # Первый итератор
print(next(it))  # 1
print(next(it))  # 2
it = iter(lst)  # Создаём новый итератор!
print(next(it))  # 1 (заново!)

Просто вызываем iter(lst) заново, и новый итератор начнёт с начала.

Использовать itertools.tee() (создаёт несколько копий итератора):
Если нельзя пересоздать итератор (например, это генератор), можно использовать itertools.tee():
import itertools
gen = (x for x in range(3))  # Генератор
it1, it2 = itertools.tee(gen)  # Создаём две копии итератора
print(next(it1))  # 0
print(next(it1))  # 1
print(next(it2))  # 0 (второй итератор не изменился!)

tee() разделяет поток на несколько независимых итераторов.

Использовать list() для полного сбора данных (если данные не бесконечные):
Если итератор не бесконечный, можно сохранить его элементы в список:
it = iter(range(5))
data = list(it)  # Собрали все элементы в список!
print(data)  # [0, 1, 2, 3, 4]
it = iter(data)  # Новый итератор с теми же данными!
print(next(it))  # 0 (начало)

Работает только для конечных итераторов, так как бесконечные могут занять всю память!

Итог:
Итератор не сбрасывается сам, next() идёт только вперёд.
Перезапуск возможен с iter(), tee(), list(), но в генераторах данные теряются!
Если данные уходят без возврата, заранее сохраняйте их в список или используйте tee().
"""
																__new__()

__new__() — создаёт новый объект класса
__new__() — это специальный метод, который вызывается до __init__().
Он создаёт новый экземпляр класса и возвращает его.

Формат:
class MyClass:
    def __new__(cls, *args, **kwargs):
        # Создание нового объекта
        instance = super().__new__(cls)
        return instance  # Обязательно вернуть новый объект
    def __init__(self, value):
        self.value = value  # `__init__()` вызывается после `__new__()`
obj = MyClass(10)  # Сначала `__new__()`, потом `__init__()`

Когда __new__() полезен?
Обычным классам он НЕ нужен — Python сам создаст объект.
Используется, если надо изменить создание объекта:

Singleton (один объект на весь класс):
class Singleton:
    _instance = None  # Храним единственный объект
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)  # Создаём только один раз!
        return cls._instance
obj1 = Singleton()
obj2 = Singleton()
print(obj1 is obj2)  # True (оба — один и тот же объект)

Гарантирует, что создастся только один экземпляр.

Наследование от immutable-классов (int, str, tuple):
Если класс наследует int, str, tuple, то их нельзя менять внутри __init__().
Но __new__() позволяет задать начальное значение:
class MyInt(int):
    def __new__(cls, value):
        return super().__new__(cls, value + 1)  # Всегда увеличиваем на 1
num = MyInt(10)
print(num)  # 11 (увеличился при создании)

__init__() не работает с int, str, но __new__() позволяет изменить объект на этапе создания.

Важное про __new__()
Вызывается первым, до __init__().
Должен вернуть объект (super().__new__(cls)).
Используется редко, в особых случаях (Singleton, int/str/tuple).
Если __new__() возвращает не cls, __init__() не вызывается.
"""
Простое объяснение __new__()

Когда ты создаёшь объект, Python делает две вещи:
Создаёт сам объект в памяти.
Настраивает объект через __init__().
Обычно Python сам создаёт объект, но если тебе нужно контролировать этот процесс, ты можешь использовать __new__().

Как это работает?
Допустим, ты покупаешь телефон в магазине:
Магазин сначала делает телефон на заводе (это __new__()).
Потом кладёт туда симку, настройки и обои (это __init__()).
Если не сделать телефон, то и настраивать нечего!
То же самое и в Python: __init__() не запустится, если __new__() не создаст объект.

Когда __new__() нужен?
Обычно он не нужен, но полезен в особых случаях:
Когда нужно создать только ОДИН объект (например, Singleton).
Когда наследуешь int, str или tuple (их нельзя менять в __init__(), но можно в __new__()).

Простые примеры:

__new__() делает так, что у класса есть только один объект:
class ОдинОбъект:
    _instance = None  
    def __new__(cls):
        if cls._instance is None:  # Если объекта ещё нет
            cls._instance = super().__new__(cls)  # Создаём его
        return cls._instance  # Потом возвращаем тот же объект
a = ОдинОбъект()
b = ОдинОбъект()
print(a is b)  # True — это один и тот же объект

Что тут происходит?
Когда мы вызываем ОдинОбъект(), программа не создаёт новый объект, а возвращает уже созданный.
Это полезно, если нам нужен только один экземпляр (например, один доступ к базе данных).

__new__() меняет значение числа перед созданием:
class МойЧисел(int):
    def __new__(cls, value):
        return super().__new__(cls, value + 1)  # Всегда +1
a = МойЧисел(10)
print(a)  # 11 (увеличился при создании)

Что тут происходит?
Мы передаём 10, но __new__() меняет его на 11, до того, как Python создаст объект.
__init__() уже получает 11, а не 10.

Простой вывод:
__new__() — это как "завод", который делает объект.
__init__() — это как "настройки", которые применяются к уже готовому объекту.
Используется редко, только если надо контролировать создание объекта.
"""
																object()										      ██████    
																												    ██░░░░░░██  
																												   ██░░    ░░██  
																												  ██░░      ░░██  
																												  ██░░      ░░██  
																												   ██░░    ░░██  
																												    ██░░░░░░██  
																												      ██████    

Функция object() создаёт пустой объект, который ничего не делает. Он является основой для всех классов в Python.

Создание пустого объекта:
obj = object()
print(obj)  # <object object at 0x...>

Что тут происходит?
object() создаёт новый объект, но он не имеет ни методов, ни атрибутов.

Нельзя добавлять атрибуты:
obj.name = "Привет"  # Ошибка: object() не поддерживает атрибуты

Почему?
object() создаёт неизменяемый объект, который нельзя модифицировать.

Используется как родительский класс:
class МояШтука(object):  # Наследуем от object
    pass

В Python 3 можно писать просто class МояШтука:
Все классы и так наследуются от object, даже если ты не пишешь это явно.

Когда object() полезен?
Создание пустого объекта, который можно передавать как заглушку.
Как родительский класс, чтобы класс имел базовые методы (__str__(), __eq__(), и т.д.).

Для проверки типа в isinstance():
print(isinstance(5, object))  # True (всё в Python — объект)
print(isinstance("abc", object))  # True
print(isinstance([], object))  # True

Вывод:
object() создаёт пустой, неизменяемый объект.
Все классы неявно наследуются от object.
В обычном коде редко используется, но полезен в базовых механиках Python.

																oct()

Функция oct(x) переводит число в восьмеричную систему счисления (основание 8).

Перевод целых чисел в восьмеричную систему:
print(oct(8))   # '0o10'
print(oct(64))  # '0o100'
print(oct(255)) # '0o377'

Как это работает?
8 в десятичной → 10 в восьмеричной
64 в десятичной → 100 в восьмеричной
255 в десятичной → 377 в восьмеричной
0o в начале строки означает восьмеричное число.

Перевод отрицательных чисел:
print(oct(-16))  # '-0o20'

Минус остаётся неизменным, а число переводится как обычно.

Работает только с целыми числами:
print(oct(3.5))  # Ошибка: TypeError

oct() не поддерживает float, нужно сначала перевести число в int().

Использование с int() для обратного перевода:
print(int('0o10', 8))  # 8
print(int('0o100', 8)) # 64

Можно обратно перевести строку с 0o в десятичное число, указав основание 8.

Когда полезно?
Работает с системами счисления.
Полезно для работы с битами и памятью (например, в файловых правах Unix).

																open()

Функция open() открывает файл для чтения, записи или других операций.

Формат вызова:
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)

Главные параметры:
file — имя файла или путь.
mode — режим открытия (чтение, запись, добавление).
encoding — кодировка (например, "utf-8").

Основные режимы открытия:
Режим	Описание
'r'		Чтение (по умолчанию). Ошибка, если файла нет.
'w'		Запись (создаёт/очищает файл).
'a'		Добавление в конец файла.
'x'		Создаёт новый файл (ошибка, если уже есть).
'b'		Бинарный режим (например, 'rb').
't'		Текстовый режим (по умолчанию).
'+'		Чтение и запись (например, 'r+').

Примеры использования:

Открытие файла для чтения:
file = open("text.txt", "r", encoding="utf-8")
print(file.read())  # Читаем содержимое
file.close()  # Закрываем файл

Запись в файл (очищает его):
file = open("text.txt", "w", encoding="utf-8")
file.write("Привет, мир!")
file.close()

Добавление в файл (не стирает данные):
file = open("text.txt", "a", encoding="utf-8")
file.write("\nДобавленный текст.")
file.close()

Чтение файла построчно:
file = open("text.txt", "r", encoding="utf-8")
for line in file:
    print(line.strip())  # strip() убирает лишние пробелы и переносы строк
file.close()

Работа с with open() (автоматическое закрытие файла):
with open("text.txt", "r", encoding="utf-8") as file:
    print(file.read())  # Читаем содержимое

Файл закроется автоматически, даже если произойдёт ошибка.

Чтение бинарных файлов (например, изображений):
with open("image.png", "rb") as file:
    data = file.read()
    print(data[:20])  # Выведет первые 20 байтов

Когда полезно?
Работа с текстовыми и бинарными файлами.
Запись, чтение и обработка данных.
Логирование информации в программе.

																ord()

Функция ord() принимает один символ и возвращает его числовой код (кодировку Unicode).

Формат вызова:
ord(char)

char — один символ (строка длиной 1).
Если передать больше одного символа, будет ошибка.

Примеры использования:

Получение числового кода символа:
print(ord('A'))  # 65
print(ord('Б'))  # 1041
print(ord('😀'))  # 128512

Работа с пробелами и знаками:
print(ord(' '))  # 32 (пробел)
print(ord('!'))  # 33
print(ord('❤'))  # 10084 (красное сердечко)

Нельзя передавать строку из нескольких символов:
print(ord("AB"))  # Ошибка: TypeError

Обратная функция — chr()
Функция chr() делает наоборот — превращает код в символ.
print(chr(65))  # 'A'
print(chr(128512))  # '😀'

Пример связи ord() и chr()
char = 'Z'
code = ord(char)  # Получаем код символа
print(code)  # 90
new_char = chr(code)  # Обратно в символ
print(new_char)  # 'Z'

Где применяется?
Работа с Unicode и кодировками.
Шифрование и преобразование текста.
Проверка символов на допустимость (например, в паролях).

																pow()											  ████████    
																												  ██░░░░░░██  
																												  ██░░░░░░██  
																												  ████████    
																												  ██          
																												  ██          
																												  ██   

Функция pow() выполняет возведение в степень и может вычислять остаток от деления.

Формат вызова:
pow(основание, степень, [модуль])

Третий параметр (модуль) необязателен.

Примеры использования:

Простое возведение в степень:
print(pow(2, 3))  # 2³ = 8
print(pow(5, 4))  # 5⁴ = 625

С отрицательной степенью (даёт дробное число):
print(pow(4, -2))  # 1 / (4²) = 0.0625

Использование третьего параметра (остаток от деления):
print(pow(2, 3, 5))  # (2³) % 5 = 8 % 5 = 3

Почему это полезно?
Ускоряет вычисления с большими числами.
Используется в криптографии.

Чем pow() отличается от **?
print(2 ** 3)   # 8  (обычное возведение в степень)
print(pow(2, 3))  # 8 (тоже самое)

pow() может работать с тремя параметрами, а ** – только с двумя.

Где полезно?
Математика (степени, модули).
Шифрование (криптография).
Быстрое вычисление степеней больших чисел.

																print()

Функция print() выводит текст, числа и другие объекты в консоль.

Основной формат вызова:
print(значение, ..., sep=' ', end='\n', file=sys.stdout, flush=False)

Аргументы:
значение, ... – что нужно вывести (можно несколько значений).
sep – разделитель между значениями (по умолчанию пробел).
end – что ставить в конце (по умолчанию \n – новая строка).
file – куда выводить (по умолчанию в консоль).
flush – принудительный вывод (по умолчанию False).

Основные примеры:

Обычный вывод:
print("Привет, мир!")  # Привет, мир!
print(10, 20, 30)  # 10 20 30

Изменение sep (разделителя):
print(1, 2, 3, sep='-')  # 1-2-3
print("Имя", "Фамилия", sep=", ")  # Имя, Фамилия

Изменение end (чем заканчивается строка):
print("Привет", end="! ")
print("Как дела?")  
# Привет! Как дела?

Запись в файл (file):
with open("output.txt", "w") as file:
    print("Это записано в файл", file=file)

Принудительный вывод (flush=True):
import time
print("Загрузка...", end="", flush=True)
time.sleep(2)
print(" Готово!")  
# "Загрузка... Готово!" (без задержки в конце)

Вывод с форматированием:
Вывод чисел с разной системой счисления:
print(bin(10), oct(10), hex(10))  # 0b1010 0o12 0xa

Форматированный вывод (f-строки):
name = "Славяна"
age = 16
print(f"Меня зовут {name}, мне {age} лет.")  
# Меня зовут Славяна, мне 16 лет.

Вывод в несколько колонок:
for i in range(1, 6):
    print(f"{i:>3} {i**2:>4} {i**3:>5}")
Вывод:
  1    1     1
  2    4     8
  3    9    27
  4   16    64
  5   25   125

Дополнительные фишки:

Вывод emoji и специальных символов:
print("\U0001F604")  # 😄
print("Символ евро: \u20AC")  # Символ евро: €

Многострочный вывод:
print("""
Первая строка
Вторая строка
Третья строка
""")

Вывод repr() вместо str():
print(repr("Привет\nМир"))  # 'Привет\nМир'

Чем print() отличается от sys.stdout.write()?
import sys
sys.stdout.write("Привет, мир!\n")

Разница:
print() автоматически добавляет пробелы и \n (если не указано end="").
sys.stdout.write() просто выводит строку как есть.

Где полезно?
Отладка (проверка кода).
Логирование данных.
Вывод в файл или другой поток.
Красивый вывод данных (форматирование, таблицы, спецсимволы).
"""
Дополнительные возможности print()
Помимо стандартных вызовов, есть форматирование строк с помощью оператора %, метода .format() и f-строк.

Форматирование через % (устаревший способ, но встречается)
Формула:
print("Формат %тип" % (значение))

Основные спецификаторы:
%d – целое число (int).
%f – число с плавающей точкой (float).
%s – строка (str).
%c – символ (str, но только один).

Примеры:
print("Число: %d" % 10)  # Число: 10
print("Число с плавающей точкой: %f" % 3.14159)  # Число с плавающей точкой: 3.141590
print("Округлённое число: %.2f" % 3.14159)  # Округлённое число: 3.14
print("Строка: %s" % "Привет")  # Строка: Привет
print("Символ: %c" % 'A')  # Символ: A

Форматирование нескольких значений:
print("Меня зовут %s, мне %d лет." % ("Славяна", 16))
# Меня зовут Славяна, мне 16 лет.

Выравнивание и ширина:
print("Число: %10d" % 123)  # Число с выравниванием вправо (10 символов)
print("Число: %-10dконец" % 123)  # Выравнивание влево

Метод .format() (современный, но менее удобный, чем f-строки)

Формула:
print("Текст {индекс}".format(значение))

Примеры:
print("Меня зовут {} и мне {} лет.".format("Славяна", 16))
# Меня зовут Славяна и мне 16 лет.

Именованные параметры:
print("Имя: {name}, возраст: {age}".format(name="Славяна", age=16))

Округление и выравнивание:
print("Число: {:.2f}".format(3.14159))  # Число: 3.14
print("Число: {:>10}".format(123))  # Выравнивание вправо (10 символов)

F-строки (самый удобный способ)
Формула:
print(f"Текст {переменная}")

Примеры:
name = "Славяна"
age = 16
print(f"Меня зовут {name}, мне {age} лет.")  
# Меня зовут Славяна, мне 16 лет.

Форматирование чисел в f-строках:
num = 3.14159
print(f"Число: {num:.2f}")  # Число: 3.14

Выравнивание:
print(f"Число: {num:>10}")  # Выравнивание вправо (10 символов)

Использование внутри переменной:
formatted = f"Число: {num:.3f}"
print(formatted)  # Число: 3.142

Сравнение методов форматирования
Метод			Пример
%				"Число: %d" % 10
.format()		"Число: {}".format(10)
f-строки		f"Число: {10}"

Вывод: f-строки удобнее всего!
"""
																property()

В Python свойство (property()) — это способ обработки атрибутов класса с добавлением логики,
которую можно вставить при доступе к этим атрибутам (чтение, запись и удаление).
Вместо того чтобы обращаться напрямую к переменной, как обычному атрибуту, можно вызвать метод,
который выполняет проверку, вычисления или другие действия, когда пытаешься получить, изменить или удалить значение.

Вот как это работает:
Чтение (геттер) — когда мы хотим получить значение какого-то атрибута.
Запись (сеттер) — когда мы хотим установить значение атрибута.
Удаление (делитер) — когда мы хотим удалить атрибут.

Параметры property()
Когда мы создаём свойство, мы можем передать функции для этих трёх операций — чтения, записи и удаления.
Эти функции называются соответственно ggetter (функция для получения значения),
setter (функция для записи значения) и deleter (функция для удаления значения).

Синтаксис:
property(fget=None, fset=None, fdel=None, doc=None)
fget — функция, которая будет вызываться при попытке чтения значения.
fset — функция, которая будет вызываться при попытке записи значения.
fdel — функция, которая будет вызываться при попытке удаления атрибута.
doc — строка, которая будет хранить описание (помощь) для свойства.

Можно ли использовать все параметры одновременно?
Да, можно передать все три функции — для чтения, записи и удаления — одновременно, но это не обязательно.
Ты можешь передать только те функции, которые тебе нужны.

Если ты не передашь функцию для геттера (fget), атрибут будет доступен только для записи, но не для чтения.
Если ты не передашь функцию для сеттер (fset), то атрибут будет доступен только для чтения, но не для изменения.
Если не передашь функцию для делитера (fdel), то атрибут не сможет быть удалён.

Пример:
Мы можем задать только fget и fset, если не хотим, чтобы атрибут можно было удалять:
class Person:
    def __init__(self, name):
        self._name = name
    def get_name(self):
        return self._name
    def set_name(self, value):
        self._name = value
    # property() с геттером и сеттером
    name = property(get_name, set_name)
p = Person("Alice")
print(p.name)  # Чтение значения (вызывается get_name)
p.name = "Bob"  # Запись нового значения (вызывается set_name)
print(p.name)  # Чтение обновленного значения

Пример с полным использованием:
В этом примере мы добавим геттер, сеттер и делитер:
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    # Геттер (получение)
    def get_area(self):
        return self._width * self._height
    # Сеттер (установка)
    def set_area(self, value):
        print("Попытка изменить площадь.")
    # Делитер (удаление)
    def del_area(self):
        print("Невозможно удалить площадь.")
    # Создаем свойство для area
    area = property(get_area, set_area, del_area)
r = Rectangle(5, 10)
print(r.area)  # Чтение: вызов get_area
r.area = 100   # Запись: вызов set_area
del r.area     # Удаление: вызов del_area

Чтение (get_area): возвращает площадь.
Запись (set_area): попытка изменить площадь, но это не разрешено (можно добавить свою логику).
Удаление (del_area): пытаемся удалить площадь, но в коде написано, что это невозможно.

Что ещё важно?
Использование без явного указания: Если мы не используем property(), то атрибуты в классе становятся обычными переменными.
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    # Нет property — просто обычный атрибут
    def area(self):
        return self._width * self._height
r = Rectangle(5, 10)
print(r.area())  # Чтение просто вызывает метод напрямую

Использование с @property: Вместо использования property() вручную, можно использовать декораторы для более компактной записи:
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height
    @property
    def area(self):
        return self._width * self._height
    @area.setter
    def area(self, value):
        print("Невозможно изменить площадь.")
    @area.deleter
    def area(self):
        print("Невозможно удалить площадь.")
r = Rectangle(5, 10)
print(r.area)  # Используется геттер
r.area = 100   # Используется сеттер
del r.area     # Используется делитер

Итог:
Геттер (получение) позволяет вычислять и возвращать значение атрибута.
Сеттер (установка) позволяет изменить атрибут, проверяя условия или выполняя дополнительные действия.
Делитер (удаление) используется, если ты хочешь запретить удаление атрибута или хочешь, чтобы его удаление происходило с дополнительной логикой.
Можно использовать только геттер или сеттер, или же все три метода — зависит от твоих требований.

																quit()											     ██████    
																												   ██░░░░░░██  
																												  ██░░    ░░██  
																												 ██░░      ░░██  
																												 ██░░   ██ ░░██  
																												  ██░░    ░░██  
																												   ██░░░░░░██  
																												     ██████    
																												          ██ 

Функция quit() используется для завершения работы программы в Python.

Формат вызова:
quit([code])

code (необязательный) — код завершения программы.
0 — успешное завершение.
1, -1 и другие — указывают на ошибку.
Можно передавать строку, которая будет напечатана перед завершением.

Отличие quit() от exit()
quit() работает так же, как exit(), но предназначен для использования в интерактивной консоли (например, в IDLE или Jupyter Notebook).
В скриптах Python лучше использовать sys.exit().

Пример 1: Простое завершение
print("Начало программы")
quit()
print("Этот текст не выведется")  # Не выполнится

Вывод:
После quit() программа завершится, и последующие строки не выполнятся.

Пример 2: Завершение с кодом ошибки
quit(1)  # Завершает программу с кодом ошибки 1

В командной строке можно проверить код завершения:
echo $?

Пример 3: Завершение с сообщением
quit("Ошибка: соединение потеряно")

Вывод:
Ошибка: соединение потеряно

Почему в скриптах quit() не рекомендуется?
quit() и exit() работают, потому что они импортируются из модуля site.
Но если Python запускается с флагом -S (без автоматического импорта site), quit() может не работать.

В скриптах лучше использовать:
import sys
sys.exit("Ошибка: критическая проблема")

Вывод:
quit() завершает выполнение программы.
Используется в интерактивном режиме (консоль, IDLE, Jupyter Notebook).
В скриптах Python лучше использовать sys.exit(), так как quit() может быть недоступен.

																range()											  ████████    
																												  ██░░░░░░██  
																												  ██░░░░░░██  
																												  ████████    
																												  ██  ██      
																												  ██    ██    
																												  ██      ██  

Функция range() — это встроенная функция в Python, которая генерирует последовательности чисел в определённом диапазоне.
Она часто используется в циклах for, чтобы итерировать по числовым значениям.
Основная особенность функции range() заключается в том, что она не создаёт список чисел сразу,
а генерирует их по мере необходимости, что позволяет экономить память при работе с большими диапазонами.

Синтаксис:
range(start, stop, step)

start — начальное значение (по умолчанию 0).
stop — конечное значение (не включается в диапазон).
step — шаг между числами (по умолчанию 1).

Пример без указания start и step:
Если указать только одно значение (например, stop), то диапазон будет от 0 до этого значения, с шагом 1.
for num in range(5):
    print(num)
Вывод:
1
2
3
4

Здесь start — это 0, stop — 5, и шаг по умолчанию 1.

Пример с указанием start и stop:
Если указаны и start, и stop, то последовательность начинается с start и заканчивается до stop.
for num in range(2, 6):
    print(num)
Вывод:
2
3
4
5

Здесь диапазон начинается с 2 и заканчивается перед 6.

Пример с шагом step:
Шаг указывает, на сколько чисел увеличивается последовательность.
for num in range(0, 10, 2):
    print(num)
Вывод:
0
2
4
6
8

Здесь шаг равен 2, поэтому числа увеличиваются на 2.

Пример с отрицательным шагом:
Шаг может быть отрицательным, что позволяет создавать последовательности в убывающем порядке.
for num in range(10, 0, -2):
    print(num)
Вывод:
10
8
6
4
2

Здесь последовательность начинается с 10 и идёт в сторону уменьшения с шагом -2.

Использование с преобразованием в список:
Можно преобразовать результат range() в список, чтобы увидеть все значения сразу:
print(list(range(3, 8)))
Вывод:
[3, 4, 5, 6, 7]

Важно помнить:
range() возвращает итерируемый объект, который можно использовать в цикле for или преобразовать в другие структуры данных,
например, в список или кортеж.
Диапазон включает начальное значение (start), но не включает конечное (stop).
range() используется в Python 3 для генерации чисел, а в Python 2 она создаёт список,
что может требовать больших объёмов памяти для длинных диапазонов.

Пример, который не создаёт список сразу:
r = range(5)
print(r)  # <range(0, 5)>
print(list(r))  # [0, 1, 2, 3, 4]

Здесь сначала создаётся объект range, и только после преобразования его в список мы видим все элементы.

Использование с отрицательными диапазонами:
r = range(10, 1, -2)
print(list(r))  # [10, 8, 6, 4, 2]

В этом примере мы создаём диапазон с шагом -2, чтобы пройти числа от 10 до 2 (не включая 1).

Когда и где используется range()?
Это одна из самых часто используемых функций в Python, особенно в циклах for.
Она позволяет удобно перебирать числа в пределах заданного диапазона, контролируя шаг и границы.

																repr()

Функция repr() в Python используется для получения строкового представления объекта, которое можно использовать для его восстановления.
В отличие от str(), которое создаёт удобочитаемую строку, repr() возвращает формальное представление объекта,
максимально приближённое к его исходному коду.

Синтаксис:
repr(object)

object — объект, строковое представление которого нужно получить.
Возвращает строку, которая представляет этот объект.

Разница между repr() и str()
repr() предназначен для отладки и внутреннего представления объектов.
str() — для удобочитаемого вывода пользователю.

Пример:
text = "Hello, world!"
print(str(text))  # Hello, world!
print(repr(text))  # 'Hello, world!'

Здесь repr() показывает строку в виде, который можно вставить в код Python.

Примеры использования repr()

Простые типы данных:
print(repr(42))        # '42'
print(repr(3.14))      # '3.14'
print(repr(True))      # 'True'

Списки, кортежи, словари:
print(repr([1, 2, 3]))      # '[1, 2, 3]'
print(repr({'a': 1}))       # "{'a': 1}"
print(repr((4, 5, 6)))      # '(4, 5, 6)'

Выходные данные выглядят так, как будто их можно вставить обратно в код.

Пользовательские классы: Если в классе определить метод __repr__(), то repr() будет возвращать его значение.
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
p = Point(3, 4)
print(repr(p))  # 'Point(3, 4)'

Здесь repr() даёт понятное и воспроизводимое представление объекта.

Когда использовать repr()?
Для отладки, чтобы видеть реальные структуры данных.
Когда нужно воссоздать объект, используя eval(repr(obj)).
При логировании и написании методов __repr__() в классах.

Важное замечание:
Если в классе нет __repr__(), Python использует стандартное представление объекта:
class Example:
    pass
print(repr(Example()))  # '<__main__.Example object at 0x7f8b3f30a6d0>'

Это не особо полезно, поэтому в реальных проектах __repr__() лучше переопределять.

Итог
repr() создаёт формальное строковое представление объекта.
Если передать его в eval(), можно восстановить объект.
Используется для отладки, логирования и в __repr__().

																read()

В Python read() — это метод, используемый для чтения данных из файловых объектов.

Синтаксис:
file.read(size=-1)

size — необязательный параметр, указывающий количество байтов/символов для чтения.
Если size не указан или равен -1, то читается весь файл.
Если указано число, например 5, то читается только 5 символов.

Примеры использования:

Чтение всего файла:
with open("example.txt", "r") as file:
    content = file.read()
    print(content)

Если файл большой, read() может занять много памяти, поэтому с огромными файлами лучше читать по частям.

Чтение части файла (size):
with open("example.txt", "r") as file:
    part = file.read(10)  # Читаем только 10 символов
    print(part)

Чтение файла по кускам (оптимально для больших файлов):
with open("example.txt", "r") as file:
    while chunk := file.read(1024):  # Читаем по 1024 байта (1 КБ)
        print(chunk)

Этот метод экономит память, так как читается не весь файл сразу.

Особенности:
После вызова read() курсор смещается дальше, поэтому повторный вызов ничего не прочитает, если не сбрасывать позицию (seek(0)).
Для бинарных файлов используется open(file, "rb"), но принцип работы такой же.

Когда использовать read()?
Если файл маленький и его можно сразу прочитать в память.
Если нужно прочитать фиксированное количество символов.
Если требуется гибкость (например, чтение по кускам для больших файлов).

																reversed()

reversed() — Функция для переворачивания последовательностей
Функция reversed() создаёт итератор, который перебирает элементы в обратном порядке.

Синтаксис
reversed(sequence)

sequence — объект, который можно перевернуть (список, строка, кортеж, range).
Возвращает итератор, а не изменяет сам объект.

Примеры использования:

Переворот списка:
nums = [1, 2, 3, 4, 5]
rev_nums = reversed(nums)
print(list(rev_nums))  # [5, 4, 3, 2, 1]

Оригинальный список остаётся неизменным.

Переворот строки:
word = "Python"
rev_word = "".join(reversed(word))
print(rev_word)  # "nohtyP"

Это создаёт новую строку, так как строки неизменяемы.

Переворот кортежа:
tpl = (10, 20, 30)
print(tuple(reversed(tpl)))  # (30, 20, 10)

Использование в цикле:
for num in reversed(range(1, 6)):
    print(num, end=" ")  # 5 4 3 2 1

Ограничения:
Не работает с set и dict (так как у них нет порядка):
print(reversed({1, 2, 3}))  # Ошибка: TypeError

Для словарей можно переворачивать ключи или значения:
d = {"a": 1, "b": 2, "c": 3}
print(list(reversed(d.keys())))  # ['c', 'b', 'a']

Когда использовать reversed()?
Если нужно перебрать элементы в обратном порядке, но без изменения оригинала.
Если нужно сохранить память, так как reversed() возвращает итератор, а не копию.

																round()

Функция round() округляет число до ближайшего целого или до указанного количества знаков после запятой.

Синтаксис:
round(number, ndigits)

number — число, которое нужно округлить.
ndigits (необязательно) — до скольки знаков округлять (если не указано — до целого).
Возвращает округлённое число типа int или float.

Примеры использования:

Округление до целого (по умолчанию):
print(round(3.6))  # 4
print(round(3.4))  # 3

Округление до заданного знака:
print(round(3.14159, 2))  # 3.14
print(round(3.14159, 3))  # 3.142

Округление отрицательных чисел:
print(round(-2.7))  # -3
print(round(-2.3))  # -2

Округление больших чисел (до десятков, сотен, тысяч):
print(round(12345, -1))  # 12350 (до десятков)
print(round(12345, -2))  # 12300 (до сотен)
print(round(12345, -3))  # 12000 (до тысяч)

Отрицательный ndigits округляет влево (до десятков, сотен и т.д.).

Как round() округляет 0.5?
Python использует банковское округление (округляет к ближайшему чётному числу):
print(round(2.5))  # 2  (к ближайшему чётному)
print(round(3.5))  # 4  (к ближайшему чётному)

В отличие от обычного округления "вверх" (2.5 → 3), здесь 2.5 округлилось до 2.

Когда использовать round()?
Когда нужно округлить вещественные числа.
При отображении данных (например, округление цен).
При финансовых расчётах (но лучше decimal.Decimal).

																set()											     ████████    
																												   ██░░░░░░░░██  
																												   ██          
																												   ██
																												     ████████    
																												             ██  
																												  ██         ██
																												  ██░░░░░░░░░██  
																												    █████████    

Функция set() создаёт множество — коллекцию уникальных элементов без порядка.

Синтаксис:
set(iterable)

iterable (необязательно) — любой итерируемый объект (list, tuple, str, range и т. д.).
Если ничего не передавать, создаётся пустое множество.

Примеры использования:

Создание множества из списка (удаляются дубликаты):
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers)
print(unique_numbers)  # {1, 2, 3, 4, 5}

Создание множества из строки:
letters = set("hello")
print(letters)  # {'h', 'e', 'l', 'o'}

Порядок символов может быть случайным!

Создание пустого множества (только через set(), {} — это пустой dict):
empty_set = set()
print(empty_set)  # set()

Преобразование множества обратно в список:
nums = [1, 2, 2, 3, 4, 4, 5]
unique_list = list(set(nums))
print(unique_list)  # [1, 2, 3, 4, 5]

Основные операции с set()

Добавление элемента:
s = {1, 2, 3}
s.add(4)
print(s)  # {1, 2, 3, 4}

Удаление элемента:
s.remove(2)  # Ошибка, если элемента нет
s.discard(5)  # Без ошибки, если элемента нет

Пересечение (&) — общие элементы:
a = {1, 2, 3}
b = {2, 3, 4}
print(a & b)  # {2, 3}

Объединение (|) — все элементы:
print(a | b)  # {1, 2, 3, 4}

Разность (-) — только в a, но не в b:
print(a - b)  # {1}

Симметрическая разность (^) — только уникальные:
print(a ^ b)  # {1, 4}

Когда использовать set()?
Когда нужно убрать дубликаты.
Когда важны уникальные элементы.
Когда нужны быстрые проверки (x in my_set быстрее, чем в списке).

																setattr()

Функция setattr() позволяет динамически (во время выполнения) изменять или добавлять атрибут объекта.

Синтаксис:
setattr(object, name, value)

object — объект, у которого устанавливается атрибут.
name — имя атрибута (строка).
value — значение, которое присваивается атрибуту.

Примеры использования:

Изменение атрибута у объекта:
class Person:
    def __init__(self, name):
        self.name = name
p = Person("Lollya")
setattr(p, "name", "Bob")  # Меняем имя
print(p.name)  # Bob

Добавление нового атрибута:
setattr(p, "age", 25)  # Добавляем новый атрибут
print(p.age)  # 25

Использование переменной как имени атрибута:
attr_name = "height"
setattr(p, attr_name, 175)  # p.height = 175
print(p.height)  # 175

Проверка перед установкой (с hasattr()):
if not hasattr(p, "weight"):
    setattr(p, "weight", 65)
print(p.weight)  # 65

Когда использовать setattr()?
Когда имена атрибутов задаются динамически (из переменных, файлов, БД).
Когда нужно изменять объекты на лету без прямого доступа.
При рефлексии (например, работа с классами и модулями).

Важно:
Если объект не поддерживает изменение атрибутов, setattr() вызовет ошибку AttributeError.
Нельзя менять атрибуты встроенных типов (setattr(5, "x", 10)).

																slice()

Функция slice() позволяет создать объект среза,
который затем можно использовать для извлечения части последовательности (списки, строки, кортежи и т. д.).

Синтаксис:
slice(start, stop, step)

start — начальный индекс (включительно). Если не указан, то по умолчанию — 0.
stop — конечный индекс (не включительно). Это обязательный параметр.
step — шаг, по которому выбираются элементы. По умолчанию — 1.

Примеры использования:
Создание среза и применение к списку:
s = [0, 1, 2, 3, 4, 5, 6]
sliced = slice(2, 5)  # Срез с 2 по 5 (не включительно)
print(s[sliced])  # [2, 3, 4]

Использование среза с шагом:
sliced_with_step = slice(0, 6, 2)  # от 0 до 6 с шагом 2
print(s[sliced_with_step])  # [0, 2, 4]

Использование среза для строки:
s = "Hello, World!"
sliced_string = slice(7, 12)
print(s[sliced_string])  # "World"

Применение среза через индексы:
s = [1, 2, 3, 4, 5, 6, 7, 8]
sliced = slice(1, 7, 2)
print(s[sliced])  # [2, 4, 6]

Использование среза с отрицательными индексами:
s = "abcdef"
sliced_negative = slice(-4, -1)
print(s[sliced_negative])  # "cd"

Когда использовать slice()?
Когда нужно создать срез с параметрами для последовательностей.
Для работы с объектами, которые поддерживают срезы (списки, строки, кортежи, и т. д.).
Когда параметры среза задаются динамически или нужно реиспользовать срез.

Особенности:
Объект среза может быть передан как аргумент для использования с любыми последовательностями, поддерживающими срезы.
Создание среза не изменяет саму последовательность, а только указывает, как выбрать её элементы.

																sorted()

Функция sorted() используется для сортировки любых итерируемых объектов (списки, строки, кортежи и т. д.) и возвращает
новый отсортированный список.

Синтаксис:
sorted(iterable, key=None, reverse=False)

iterable — итерируемый объект (например, список, строка, кортеж), который вы хотите отсортировать.
key — функция, которая будет применяться к каждому элементу для
извлечения ключа сортировки (по умолчанию None, то есть сортировка по самим элементам).
reverse — если True, то сортировка будет в порядке убывания (по умолчанию False, то есть сортировка по возрастанию).

Примеры использования:

Сортировка списка по возрастанию:
numbers = [5, 3, 8, 1, 2]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # [1, 2, 3, 5, 8]

Сортировка строки:
s = "hello"
sorted_string = sorted(s)
print(sorted_string)  # ['e', 'h', 'l', 'l', 'o']

Сортировка по убыванию:
numbers = [5, 3, 8, 1, 2]
sorted_descending = sorted(numbers, reverse=True)
print(sorted_descending)  # [8, 5, 3, 2, 1]

Сортировка с использованием key:
words = ["apple", "banana", "cherry", "date"]
# Сортируем по длине строки
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # ['date', 'apple', 'banana', 'cherry']

Сортировка словаря по ключам или значениям:
d = {"a": 3, "c": 1, "b": 2}
# Сортировка по ключам
sorted_by_keys = sorted(d)
print(sorted_by_keys)  # ['a', 'b', 'c']
# Сортировка по значениям
sorted_by_values = sorted(d, key=lambda x: d[x])
print(sorted_by_values)  # ['c', 'b', 'a']

Когда использовать sorted()?
Когда нужно отсортировать итерируемые объекты (списки, строки, кортежи и т. д.).
Когда нужно упорядочить элементы по определённому правилу с помощью параметра key.
Когда требуется сортировка по убыванию или по конкретным критериям.

Особенности:
sorted() возвращает новый отсортированный список. Оригинальный объект остаётся неизменным.
Использование key позволяет сортировать элементы по пользовательским правилам (например, по длине строки или числовым значениям в словаре).
reverse=True изменяет порядок сортировки на обратный.

																str()

Функция str() используется для преобразования объекта в строковое представление.

Синтаксис:
str(object='')

object — объект, который нужно преобразовать в строку. Если аргумент не передан, то по умолчанию будет использована пустая строка.

Примеры использования:

Преобразование числа в строку:
num = 123
str_num = str(num)
print(str_num)  # "123"

Преобразование списка в строку:
lst = [1, 2, 3]
str_lst = str(lst)
print(str_lst)  # "[1, 2, 3]"

Преобразование булевого значения в строку:
is_true = True
str_bool = str(is_true)
print(str_bool)  # "True"

Преобразование None в строку:
nothing = None
str_nothing = str(nothing)
print(str_nothing)  # "None"

Преобразование с использованием пользовательского объекта:
class Person:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return f"Person: {self.name}"
person = Person("Lollya")
str_person = str(person)
print(str_person)  # "Person: Lollya"

В этом примере, если в классе определён метод __str__(), то str() будет использовать его для получения строкового представления объекта.

Когда использовать str()?
Когда нужно преобразовать объект в строку, чтобы, например, вывести его на экран.
Когда необходимо представить числовые или другие данные в виде строки для дальнейшей обработки или вывода.

Особенности:
Если объект не имеет явного строкового представления, функция str() вызовет его метод __str__(), если таковой имеется.
Если метод __str__() не определён, будет использовано стандартное строковое представление объекта (например, его адрес в памяти).

																sum()

Функция sum() используется для нахождения суммы элементов в итерируемом объекте (например, список, кортеж).

Синтаксис:
sum(iterable, start=0)

iterable — итерируемый объект (например, список, кортеж), содержащий числовые элементы.
start — начальное значение суммы, которое добавляется к результату (по умолчанию равно 0).

Примеры использования:

Сумма элементов списка:
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)
print(total)  # 15

Здесь мы просто вычисляем сумму чисел в списке.

Сумма элементов с начальным значением:
numbers = [1, 2, 3, 4, 5]
total_with_start = sum(numbers, 10)
print(total_with_start)  # 25

Здесь мы начинаем с 10 и прибавляем к нему сумму элементов списка. Результат: 10 + 1 + 2 + 3 + 4 + 5 = 25.

Сумма с отрицательными числами:
numbers = [-1, -2, 3, 4]
total = sum(numbers)
print(total)  # 4

Функция работает корректно и с отрицательными числами.

Сумма чисел в кортежах или других итерируемых объектах:
values = (10, 20, 30)
total = sum(values)
print(total)  # 60

sum() также работает с кортежами.

Пример с использованием строки (не рекомендовано, но возможно):
letters = 'abc'
total = sum(ord(c) for c in letters)
print(total)  # 294 (сумма ASCII кодов символов)

В этом примере мы преобразуем каждый символ строки в его ASCII код с помощью ord() и суммируем их.

Когда использовать sum()?
Когда нужно вычислить сумму числовых данных в итерируемом объекте.
Когда нужно добавить начальное значение к сумме (например, для подсчёта с учётом дополнительной базы).

Особенности:
Функция sum() работает только с числовыми данными. Если итерируемый объект содержит нечисловые элементы, возникнет ошибка.
start полезен для случаев, когда требуется не просто сумма чисел, а добавление дополнительной константы к итоговому результату.

																super()

Функция super() используется для вызова методов или конструкторов родительского класса из дочернего класса.
Это важно для расширения функционала классов и правильной работы с наследованием.

Синтаксис:
super([type[, object-or-type]])

type — класс, для которого вызываются методы родительского класса. Обычно указывают текущий класс (например, class Child).
object-or-type — объект или класс, от которого нужно вызывать методы. Это необязательный параметр.
Если оба параметра опущены, то super() по умолчанию работает с ближайшим родительским классом.

Примеры использования:

Вызов конструктора родительского класса:
class Animal:
    def __init__(self, name):
        self.name = name
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Вызов конструктора родительского класса
        self.breed = breed
dog = Dog("Rex", "German Shepherd")
print(dog.name)  # Rex
print(dog.breed)  # German Shepherd

Здесь super().__init__(name) вызывает конструктор родительского класса Animal, чтобы правильно инициализировать имя для объекта.

Вызов метода родительского класса:
class Animal:
    def speak(self):
        print("Animal speaks")
class Dog(Animal):
    def speak(self):
        super().speak()  # Вызов родительского метода
        print("Woof!")
dog = Dog()
dog.speak()  # Animal speaks \n Woof!

В этом примере метод speak() в классе Dog вызывает метод speak() родительского класса Animal через super(),
а затем добавляется поведение для собак.

Множественное наследование:
class A:
    def hello(self):
        print("Hello from A")
class B:
    def hello(self):
        print("Hello from B")
class C(A, B):
    def hello(self):
        super().hello()  # Вызов метода от первого родительского класса (A)
        print("Hello from C")
c = C()
c.hello()  # Hello from A \n Hello from C

Здесь super() вызывает метод от первого родительского класса A в случае множественного наследования.

Когда использовать super()?
Когда нужно вызывать методы или конструкторы родительского класса.
Когда хотите расширить функциональность метода родительского класса, добавив новый код в дочернем классе.
Когда нужно работать с множественным наследованием и указывать, какой именно родительский класс должен быть вызван.

Особенности:
super() помогает избежать дублирования кода и делает наследование более гибким.
В случае множественного наследования Python использует метод MRO (Method Resolution Order) для определения,
какой родительский класс будет вызван первым.

																sys.exit()

Функция sys.exit() завершает выполнение программы в Python, вызывая SystemExit.

Формат вызова:
import sys
sys.exit([code])

code (необязательный) — код завершения программы.
0 — успешное завершение (по умолчанию).
1, -1 и другие — указывают на ошибку.
Можно передавать строку с причиной завершения.

Отличие sys.exit() от quit()
sys.exit() работает везде, в том числе в скриптах.
quit() и exit() работают только в интерактивном режиме (они не всегда доступны в скриптах).

Пример 1: Завершение программы
import sys
print("Программа запущена")
sys.exit()
print("Этот код не выполнится")  # Не выполнится

Вывод:
После sys.exit(), выполнение прекращается.

Пример 2: Завершение с кодом ошибки
import sys
if True:  # Симуляция ошибки
    sys.exit(1)

В командной строке можно проверить код завершения:
echo $?

Пример 3: Завершение с сообщением
import sys
sys.exit("Ошибка: соединение потеряно")

Вывод:
Ошибка: соединение потеряно

Пример 4: sys.exit() внутри try-except
sys.exit() вызывает исключение SystemExit, но его можно перехватить:
import sys
try:
    sys.exit("Произошла ошибка")
except SystemExit as e:
    print(f"Программа завершилась с сообщением: {e}")

Вывод:
Программа завершилась с сообщением: Произошла ошибка

Вывод:
sys.exit() — стандартный и надежный способ завершения программ Python.
Используется в скриптах и в обработке ошибок.
Работает лучше, чем quit(), потому что доступен всегда.

																tuple()											  ██████████  
																												      ██      
																												      ██      
																												      ██      
																												      ██      
																												      ██      
																												      ██ 

Функция tuple() используется для создания кортежа — неизменяемого списка, то есть последовательности,
элементы которой нельзя изменять, добавлять или удалять после создания.

Синтаксис:
tuple([iterable])

iterable — любой итерируемый объект (например, список, строка, множество и т.д.).
Этот аргумент является необязательным, и если его не передать, то будет создан пустой кортеж.

Примеры использования:

Создание кортежа из списка:
numbers = [1, 2, 3, 4]
tuple_numbers = tuple(numbers)
print(tuple_numbers)  # (1, 2, 3, 4)

Здесь мы создаём кортеж tuple_numbers из списка numbers. Элементы списка становятся элементами кортежа.

Создание пустого кортежа:
empty_tuple = tuple()
print(empty_tuple)  # ()

Если не передавать аргумент в tuple(), то результатом будет пустой кортеж ().

Создание кортежа из строки:
string = "hello"
tuple_string = tuple(string)
print(tuple_string)  # ('h', 'e', 'l', 'l', 'o')

В этом примере строка "hello" превращается в кортеж, где каждый символ строки является отдельным элементом кортежа.

Кортеж с одним элементом:
single_element_tuple = tuple([5])
print(single_element_tuple)  # (5,)

Для создания кортежа с одним элементом нужно передать его в виде списка (или другого итерируемого объекта),
потому что просто написание tuple(5) приведёт к ошибке.

Когда использовать tuple()?
Когда нужно создать неизменяемую последовательность данных.
Это полезно для хранения данных, которые не должны изменяться в процессе работы программы.
Когда хотите передавать данные в функции, которые должны оставаться константными.
Когда требуется использовать кортежи в качестве ключей в словарях, так как кортежи являются хешируемыми.

Особенности кортежа:
Кортежи являются неизменяемыми, в отличие от списков, поэтому они не поддерживают операции изменения, такие как добавление,
удаление или изменение элементов.
Кортежи могут содержать различные типы данных, включая другие кортежи, списки и даже объекты.

																type()

Функция type() выполняет две основные задачи:
Определение типа объекта
Динамическое создание классов

Определение типа объекта:
Синтаксис:
type(object)

Возвращает тип переданного объекта:
Примеры:
print(type(10))        # <class 'int'>
print(type(3.14))      # <class 'float'>
print(type("Hello"))   # <class 'str'>
print(type([1, 2, 3])) # <class 'list'>
print(type({1, 2, 3})) # <class 'set'>
print(type(None))      # <class 'NoneType'>

type() позволяет проверить, к какому типу относится объект.

Динамическое создание классов:
Синтаксис:
type(name, bases, attributes)

name — имя нового класса (строка).
bases — кортеж родительских классов.
attributes — словарь атрибутов и методов класса.

Пример создания класса с type():
MyClass = type('MyClass', (), {'x': 10, 'show': lambda self: print("Привет!")})
obj = MyClass()  # Создание экземпляра класса
print(obj.x)     # 10
obj.show()       # Привет!

Здесь type() создаёт новый класс MyClass, у которого есть атрибут x = 10 и метод show().

Когда использовать type()?
Проверять тип переменной во время выполнения программы.
Динамически создавать классы, если заранее неизвестна их структура.

																vars()											  ██      ██  
																												  ██      ██  
																												  ██      ██  
																												  ██      ██  
																												   ██    ██   
																												    ██  ██    
																												      ██      

Функция vars() возвращает __dict__ объекта — словарь его атрибутов.

Формат вызова:
vars([object])

Если object не указан, vars() ведёт себя как locals() и возвращает локальные переменные.

Пример 1: Получение атрибутов объекта
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
p = Person("Lollya", 25)
print(vars(p))  
# {'name': 'Lollya', 'age': 25}

Возвращает все атрибуты объекта в виде словаря.

Пример 2: Использование без аргументов (эквивалент locals())
x = 10
y = "hello"
print(vars())  
# {'x': 10, 'y': 'hello', ...}

Выводит все переменные текущей области.

Ограничения:
Работает только с объектами, у которых есть __dict__.
Например, у list, int, tuple нет __dict__, и вызов vars(5) приведёт к ошибке:
print(vars(5))  # AttributeError
Если передать объект с __slots__, тоже будет ошибка.

Вывод:
vars(obj) — получить атрибуты объекта в виде словаря.
vars() — показать локальные переменные.
Работает только с объектами, имеющими __dict__.

																write()											  ██        ██  
																												  ██        ██  
																												  ██   ██   ██  
																												  ██  ████  ██  
																												  ██ █    █ ██  
																												  ███      ███  
																												  ██        ██  

Функция write() используется для записи данных в файл.

Формат вызова:
file.write(string)

Записывает строку в файл.
Не добавляет автоматический перенос строки (\n).
Возвращает количество записанных символов.

Пример 1: Запись текста в файл
with open("example.txt", "w") as file:
    file.write("Привет, мир!")

Файл example.txt теперь содержит:
Привет, мир!

Пример 2: Запись нескольких строк
with open("example.txt", "w") as file:
    file.write("Первая строка\n")
    file.write("Вторая строка")

Теперь в файле:
Первая строка
Вторая строка

Пример 3: Запись списка строк (writelines())
lines = ["Первая строка\n", "Вторая строка\n"]
with open("example.txt", "w") as file:
    file.writelines(lines)

Важно: writelines() не добавляет \n, поэтому строки надо передавать уже с переносами.

Пример 4: Дописывание в файл (a вместо w)
with open("example.txt", "a") as file:
    file.write("\nТретья строка")

Теперь файл содержит:
Первая строка
Вторая строка
Третья строка

Пример 5: Запись чисел (ошибка и решение)
with open("example.txt", "w") as file:
    file.write(123)  # TypeError

Нельзя записывать числа напрямую. Нужно сначала преобразовать их в строку: file.write(str(123)) 

Вывод:
write() записывает строки в файл.
writelines() записывает список строк.
write() возвращает количество записанных символов.
Для записи чисел нужно использовать str().

																zip()											  ██████████  
																												        ██    
																												      ██      
																												    ██        
																												  ██          
																												  ██░░░░░░░░  
																												  ██████████  

Функция zip() используется для объединения нескольких итерируемых объектов (списков, кортежей, строк и т. д.) в один.

Формат вызова:
zip(iter1, iter2, ...)

Принимает несколько итерируемых объектов.
Создаёт итератор кортежей, где элементы берутся поштучно из переданных объектов.
Останавливается на самом коротком объекте.

Пример 1: Объединение списков
names = ["Аня", "Борис", "Вика"]
ages = [30, 25, 36]
result = zip(names, ages)
print(list(result))

Вывод:
[('Аня', 30), ('Борис', 25), ('Вика', 36)]

Пример 2: Разная длина списков
a = [1, 2, 3]
b = ['a', 'b']
print(list(zip(a, b)))

Вывод:
[(1, 'a'), (2, 'b')]

Функция игнорирует лишние элементы длинного списка.

Пример 3: Распаковка (обратная операция)
pairs = [(1, 'a'), (2, 'b'), (3, 'c')]
nums, letters = zip(*pairs)
print(nums)     # (1, 2, 3)
print(letters)  # ('a', 'b', 'c')

Вывод:
(1, 2, 3)
('a', 'b', 'c')

*zip() распаковывает список кортежей обратно в отдельные списки.

Пример 4: Использование в цикле for
users = ["Алиса", "Боб", "Чарли"]
scores = [90, 80, 85]
for user, score in zip(users, scores):
    print(f"{user}: {score}")

Вывод:
Алиса: 90
Боб: 80
Чарли: 85

Удобно использовать для одновременного перебора нескольких списков.

Пример 5: zip() + dict()
keys = ["имя", "возраст", "Планета"]
values = ["Иван", 25, "Земля"]
dictionary = dict(zip(keys, values))
print(dictionary)

Вывод:
{'имя': 'Иван', 'возраст': 25, 'Планета': 'Земля'}

Позволяет создавать словари из двух списков.

Вывод:
zip() группирует элементы из нескольких итерируемых объектов.
Останавливается, когда кончается самый короткий объект.
Можно использовать с *zip(), dict(), циклами и списковыми выражениями.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



План:
Дописать не достающие функции и тд
дописать описание ко всему
написать возможные фишки
написать все термины

"""
        ████████  
            ██    
            ██    
            ██    
  ██        ██    
  ██░░      ██    
    ██▓▓▓▓██      
      ████        

  ██      ██  
  ██    ██    
  ██  ██      
  ████        
  ██  ██      
  ██    ██    
  ██      ██  
          
     

  ██      ██  
  ██      ██  
  ██      ██  
  ██      ██  
  ██      ██  
  ██░░  ░░██  
    ██████    


  ██      ██  
   ██    ██    
    ██  ██    
      ██      
    ██  ██    
   ██    ██    
  ██      ██  

  ██      ██  
   ██    ██    
    ██  ██    
      ██      
      ██      
      ██      
      ██      
"""
      															Черновая версия обучения, получившаяся неудачной:

Генераторы списков (List comprehensions) – компактный способ создания новых списков на основе существующих.
a = [1, 2, 3, 4]
b = [x * 2 for x in a]
print(b)
-------------------------------------------------------------------------------------------------------------------------------------------------
Переменные в print:
a = ggg
b - 234
print(f"uuuuuuuu, {a}! gggg {b} hhh.")
=
uuuuuu, ggg! gggg 234 hhh.
------------------------------------------------------------------------------
a = ggg
b - 234
print("uuuuuuuu, {a}! gggg {b} hhh.")
=
uuuuuuuu, {a}! gggg {b} hhh.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Списки:
a = [1, 2, 3, "четыре", 5.0]
print(a[0])
print(a[3])
=
1		#первый элемент
четыре		#четвертый элемент
------------------------------------------------------------------------------
a = [1, 2, 3, "четыре", 5.0]
print(a[-1])
=
5.0		#последний элемент
------------------------------------------------------------------------------
a = [1, 2, 3, "четыре", 5.0]
a[1] = "два"
print(a)
=
[1, "два", 3, "четыре", 5.0]	#Изменение второго елемента
------------------------------------------------------------------------------
a = [1, "два", 3, "четыре", 5.0]
a.append(6)
print(a)
=
[1, "два", 3, "четыре", 5.0, 6]	#добавляет элемент в конец
------------------------------------------------------------------------------
a = [1, "два", 3, "четыре", 5.0, 6]
a.insert(1, "агуша")
print(a)
=
[1, "агуша", "два", 3, "четыре", 5.0, 6]	#вставляет на позицию 1
------------------------------------------------------------------------------
a = [1, "агуша", "два", 3, "четыре", 5.0, 6]
a.remove("два")
print(a)
=
[1, "агуша", 3, "четыре", 5.0, 6]	#удаляет первый указанный элемент
------------------------------------------------------------------------------
a = [1, "агуша", 3, "четыре", 5.0, 6]
ab = a.pop()
print(ab)
print(a)
=
6
[1, "агуша", 3, "четыре", 5.0,]
#pop()=удаляет элемент по указаному индексу и возращает его.
#Если элемент не указан, удаляет последний элемент.
------------------------------------------------------------------------------
a = [1, "агуша", 3, "четыре", 5.0,]
print(len(a))
=
5		#количество элементов
------------------------------------------------------------------------------
a = [1, "агуша", 3, "четыре", 5.0,]
a.reverse()
print(a)
=
[5.0, "четыре", 3, "агуша", 1]	#разворачивает порядок элементов в списке.
------------------------------------------------------------------------------
b = [5, 3, 6, 1, 9]	|	b = ["gdh", "da", "as", "b"]
b.sort()		|	b.sort()
print(b)		|	print(b)
=			|	=
[1, 3, 5, 6, 9]		|	["as", "b", "da", "gdh"]
#сортирует элементы списка только для чисел и строк.
------------------------------------------------------------------------------
c = [1, 2, 3, 4, 5, 6]
ca = c[1:4]
print(ca)
=
[2, 3, 4]	#эелементы с индексами 1, 2, и 3
------------------------------------------------------------------------------
c = [1, 2, 3, 4, 5, 6]
print(с[:3])	#[1, 2, 3]	#с начала до индекса 3
print(с[3:])	#[4, 5, 6]	#с индекса 3 до конца
print(с[-3:])	#[4, 5, 6]	#последние три элемента
------------------------------------------------------------------------------
c = [1, 2, 3, 4, 5,]
print(3 in c)
print(6 in c)
=
True
False
#проверка содержания
------------------------------------------------------------------------------
c = [1, 2, 3]
ca = c.copy()		#копирования списка
ca[0] = 99
print(c)
print(ca)
=
[1, 2, 3]	#оригинал не изменился
[99, 2, 3]	#копия изменена
------------------------------------------------------------------------------
c = [1, 2, 3]
cc = [4, 5, 6]
cca = c + cc	#обьединение списков
print(cca)
=
[1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------
c = [1, 2, 3]
cc = [4, 5, 6]
c.extend(cc)	#добавление элементов второго списка в первый
print(c)
=
[1, 2, 3, 4, 5, 6]
------------------------------------------------------------------------------
c = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(c[1][2])
=
6		#вывод второй список третий элемент
------------------------------------------------------------------------------
c = [1, 2, 3]
a, b, d = c	#упаковка
print(a, b, d)
=
1 2 3
------------------------------------------------------------------------------
Генераторы списков:
d = [x ** 2 for x in range(10)]		#квадраты чисел от 0 до 9
print(d)
=
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
------------------------------------------------------------------------------
Кортеж:
Кортеж нельзя изменить.
Кортеж - ()
(a[b]) - кортеж + список
Кортеж производительней и опитмизированей по памяти чем список.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Цикл:
break - останавливает и прекращает весь код в цикле котого он находиться
	и переходит к коду который находиться после цикла.
i = 0
while i < 10:
    if i == 5:
        break
    print(i)
    i += 1
=
0
1
2
3
4
------------------------------------------------------------------------------
continue - в цикле в котором continue, все что под continue не срабатывает,
	   цикл не прекращаееться.
i = 0
while i < 5:
    i +=1
    if i == 3:
        continue
    print(i)
=
1
2
4
5
------------------------------------------------------------------------------
Цикл for:			|
c = [1, 2, 3, 4, 5]		|c = (10, 20, 30)
for ca in c:			|for ca in c:
    print(ca)			|print(ca)
=				|=
1				|10
2				|20
3				|30
4				|
5				|
#элементы списки		|#кортеж
------------------------------------------------------------------------------
c = [1, 2, 3, 4, 5]
for ac in range(5):
    print(ca)
=
0
1
2
3
4
#последовательность
------------------------------------------------------------------------------
for c in range(1, 10, 2):	#range(начало, конец, шаг)
    print(c)
=
1
3
5
7
9
------------------------------------------------------------------------------
for c in "Python":
    print(c)
=
P
y
t
h
o
n
#перебор строки по символам
------------------------------------------------------------------------------
for c in range(3):
    for d in range(2):
        print(c, d)
=
0 0
0 1
1 0
1 1
2 0
2 1
#цикл в цикле
------------------------------------------------------------------------------
c = ["a", "b", "c"]
for cc, ccc in enumerate(c):
    print(cc, ccc)
=
0 a
1 b
2 c
#перебор списков и последовательностей
------------------------------------------------------------------------------
с = [1, 2, 3, 4]
for a in reversed(с):
    print(a)
=
4
3
2
1
#Перебор в обратном порядке с reversed()
------------------------------------------------------------------------------
#Оператор else в цикле for.
#
Оператор else может использоваться с циклом for.
#Он выполняется только тогда, когда цикл завершился без использования break.
for a in range(5):
    print(a)
else:
    print("Цикл завершен без break")
=
0
1
2
3
4
Цикл завершен без break
------------------------------------------------------------------------------
#Пример с break:
for a in range(5):
    if a == 3:
        break
    print(a)
else:
    print("Цикл завершен без break")
=
0
1
2
#Здесь else не выполнится, потому что цикл был прерван оператором break.
------------------------------------------------------------------------------
#Однострочный for.
#
Иногда можно написать цикл for в одну строку. Это называется генератором
#списка и используется для создания списков на основе циклов.
c = [a ** 2 for a in range(5)]
print(c)
=
[0, 1, 4, 9, 16]
------------------------------------------------------------------------------
Сжатие/разжатие списков и кортеж:
c = [1, 2, 3]
d = ['a', 'b', 'c']
for a, b in zip(c, d):
    print(a, b)
=
1 a
2 b
3 c
#Функция zip() объединяет несколько последовательностей (например, списки или
#кортежи) и возвращает их элементы по одному, парами или группами, в
#зависимости от количества последовательностей.
#Соединяет элементы с одинаковыми индексами из обоих списков в кортежи.
------------------------------------------------------------------------------
c = [1, 2, 3, 4]
d = ['a', 'b']
for a, b in zip(c, d):
    print(a, b)
=
1 a
2 b
#Длины списков разные.
------------------------------------------------------------------------------
c = [1, 2, 3]
d = ['a', 'b', 'c']
e = [True, False, True]

for a, b, c in zip(c, d, e):
    print(a, b, c)
=
1 a True
2 b False
3 c True
#Больше двух списков.
------------------------------------------------------------------------------
#Сжатие:
c = [1, 2, 3]
d = ['a', 'b', 'c']
e = list(zip(c, d))
print(e)
=
[(1, 'a'), (2, 'b'), (3, 'c')]
#Можно преобразовать в список или кортеж,
#если нужно сразу получить доступ к сгенерированным группам элементов.
#Это создаст список кортежей, где каждый кортеж
#содержит элементы с одинаковыми индексами из обоих списков.
------------------------------------------------------------------------------
#Разжатие:
#Если есть список кортежей, полученных с помощью zip(),
#можно "разжать" их обратно в отдельные списки, используя zip(*...)
c = [(1, 'a'), (2, 'b'), (3, 'c')]

d, e = zip(*c)
print(d)
print(e)
=
(1, 2, 3)
('a', 'b', 'c')
------------------------------------------------------------------------------
#Но что, если нужно изменить данные?

c = ['Alice', 'Bob', 'Charlie']
d = [85, 90, 95]
e = list(zip(c, d))
print(e)
=
[('Alice', 85), ('Bob', 90), ('Charlie', 95)]
# Создаем список кортежей

f = [list(h) for h in e]
print(f)
=
[['Alice', 85], ['Bob', 90], ['Charlie', 95]]
# Преобразуем каждый кортеж в список, чтобы сделать его изменяемым.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операторы:
#Тернарный оператор.
c = "Even" if a % 2 == 0 else "Odd"
print(c)
=
Even
------------------------------------------------------------------------------
except:
    #перехватывает любую ошибку, однако менее ефективен чем "except ***:"
    #с указанием типа ошибки
------------------------------------------------------------------------------
#Исключения:

try:
    # Код, который может вызвать ошибку
except Ошибка1:
    # Обработка ошибки1
except Ошибка2:
    # Обработка ошибки2
else:
    # Этот блок выполняется, если ошибки не было
finally:
    # Этот блок выполнится в любом случае, независимо от ошибки
------------------------------------------------------------------------------
#Пример:

try:
    a = int(input("Введите число: "))
    b = 10 / a
except ValueError:
    print("Ошибка: Введено не число!")
except ZeroDivisionError:
    print("Ошибка: Деление на ноль!")
else:
    print("Результат:", b)
finally:
    print("Этот блок выполнится в любом случае.")

#except ValueError: срабатывает, если пользователь ввел не число.
#except ZeroDivisionError: срабатывает, если произошло деление на ноль.
#
else: выполняется, если ошибки не было.
#
finally: выполняется в любом случае, даже если в try возникла ошибка.
------------------------------------------------------------------------------
#Пример с FileNotFoundError:
try:
    file = open('non_existent_file.txt', 'r')
except FileNotFoundError:
    print("Файл не найден!")
=
Файл не найден!
------------------------------------------------------------------------------
try:
    x = int(input("Введите число: "))
    c = 10 / x
except ValueError as e:
    print(f"Ошибка: {e}")  # Выводит текст ошибки
except ZeroDivisionError as e:
    print(f"Ошибка: {e}")  # Выводит текст ошибки

#Конструкция as e в блоке except позволяет сохранить информацию об ошибке,
#которая произошла, в переменной e.
#Это дает возможность вывести подробности об ошибке или выполнить
#дополнительные действия в зависимости от конкретного исключения.
------------------------------------------------------------------------------
#Чтобы поймать любую ошибку с использованием as, что даёт полную информацию об
#ошибке, обязательно после except нужно писать Exception.

try:
    x = int(input("Введите число: "))
    с = 10 / x
except Exception as e:  # Exception — базовый класс для всех исключений
    print(f"Произошла ошибка: {e}")
------------------------------------------------------------------------------
#При использовании as, при вводе конкретного типа ошибки можно получить
#больше информации о ней если такова будет в коде.
------------------------------------------------------------------------------
#Примеры: код с общим исключением.
#Возможные случаи ввода и их результаты:
#1)Ввод корректного числа (например, 5):


#  Ввод: 5

#  Вывод: c будет равен 2.0 (10 делим на 5),
#  и программа завершится без ошибок, ничего не выведет.
#2)
Ввод 0:


#  
Вывод: Произошла ошибка: division by zero
#  
Это вызовет ZeroDivisionError, и код перейдёт в блок except,
#  где e будет содержать сообщение об ошибке.
#3)
Ввод некорректного значения (например, "abc"):
#  

Ввод: abc

#  Вывод: Произошла ошибка: invalid literal for int() with base 10: 'abc'

#  Это вызовет ValueError, и снова код перейдёт в блок except.
#4)
Ввод пустой строки (просто нажать Enter):
#  

Ввод: (пустая строка)

#  Вывод: Произошла ошибка: invalid literal for int() with base 10: ''

#  Это тоже вызовет ValueError, так как пустую строку невозможно
#  преобразовать в целое число.
------------------------------------------------------------------------------
#Примеры: Код с конкретным исключением.
try:
    x = int(input("Введите число: "))
    result = 10 / x
except ValueError as e:
    print(f"Ошибка ввода: {e}")
except ZeroDivisionError as e:
    print(f"Ошибка деления: {e}")
#Возможные случаи ввода и их результаты:
#1)Ввод корректного числа (например, 5):
#  

Ввод: 5

#  Вывод: result будет равен 2.0, и программа завершится без ошибок,
#  ничего не выведет.
#2)
Ввод 0:


#  
Вывод: Ошибка деления: division by zero
#  
Это вызовет ZeroDivisionError,
#  и код перейдёт в блок except ZeroDivisionError.
#3)
Ввод некорректного значения (например, "abc"):
#  

Ввод: abc
#  
Вывод: Ошибка ввода: invalid literal for int() with base 10: 'abc'

#  Это вызовет ValueError, и код перейдёт в блок except ValueError.
#4)
Ввод пустой строки (просто нажать Enter):


#  Ввод: (пустая строка)

#  Вывод: Ошибка ввода: invalid literal for int() with base 10: ''

#  Это также вызовет ValueError.
------------------------------------------------------------------------------
#Несколько распространённых типов исключений.

#1)Exception: базовый класс для всех встроенных исключений.
#  Используя except Exception as e:, можно ловить любые ошибки.
#2)ValueError: возникает, когда передано неправильное значение
#  (например, нечисловая строка при попытке преобразования в число).
#3)

TypeError: возникает, когда операции выполняются над несовместимыми типами.
#4)

IndexError: возникает, когда индекс выходит за пределы списка или
#  другой последовательности.


#5)KeyError: возникает, когда запрашивается несуществующий ключ в словаре.
#6)

ZeroDivisionError: возникает при попытке деления на ноль.


#7)FileNotFoundError: возникает при попытке открытия несуществующего файла.
#8)

AttributeError: возникает, когда пытаешься обратиться к атрибуту объекта,
#  который не существует.
#9)

ImportError: возникает, когда не удаётся импортировать модуль.
#10)

NameError: возникает, когда имя переменной не определено.


#11)OSError: базовый класс для ошибок, связанных с операционной системой
#  (например, ошибки ввода-вывода).
#12)

KeyboardInterrupt: возникает при прерывании выполнения программы
#  (например, при нажатии Ctrl + C).
------------------------------------------------------------------------------
#Дополнительно:
#1)Общее исключение (except Exception as e):
#  Обрабатывает все возможные ошибки.
#  Сообщает лишь о том, что произошла ошибка, и указывает её описание 
#  на английском.
#  Не предоставляет детальной информации о том, какая именно ошибка произошла,
#  что может затруднить понимание проблемы для пользователя.

#2)Конкретные исключения
#  по типу (except ValueError as e, except ZeroDivisionError as e):
#  Обрабатывает конкретные типы ошибок.
#  Позволяет давать более чёткие и понятные сообщения об ошибках
#  (на языке который выбран у вас, а после уже выводит на английском ошибку).
#  Указывает, что именно произошло, и предоставляет более точную информацию,
#  что помогает пользователю понять, что он сделал неправильно.
------------------------------------------------------------------------------
def a(b):
    if b < 0:
        raise ValueError("Число не должно быть отрицательным!")
    return b

try:
    print(a(-5))
except ValueError as e:
    print(e)
=
Число не должно быть отрицательным!

#Вызов функций: *имя функции*()
#В скобках можно создать переменные и не только.
#(b) — это параметры функции, которые позволяют передавать данные
#в функцию при её вызове. В данном случае b — это единственный параметр.
#Пример:

def a(b):			# a — это имя функции

    print(f"Hello, {b}!")	# Используем параметр b


a("Alice")			# Вызов функции с аргументом "Alice"
=
Hello, Alice!

#В скобках после имени функции можно указывать параметры,
#и в них может быть как переменная, так и другие выражения.
#Когда вызываешь функцию, передаються ей аргументы,
#которые будут записаны в параметры.
#Пример:

def a(x):		# x — параметр функции
    return x * x
b = a(5)		# 5 — аргумент, который передается в параметр x
print(b)
=
25
#В этом примере x — параметр функции a,
#и при вызове a(5) значение 5 записывается в x.

#Если передавать 10, то x будет равно 10, и результат будет 100.
------------------------------------------------------------------------------
#return - ето то что позволяет результат чего либо, будь то числа
#или строки перезаписать в переменную созданую в функции.
#Ещё пример:
def a(b):			# Добавили параметр b
    print(f"Hello, {b}!")

a("Alice")
a("Bob")
=
Hello, Alice!
Hello, Bob!

#Можно передавать функции и результаты других выражений в качестве аргументов.
#Например:

def ddd(a, b):
    return a + b

def kkk(c):
    return c * 2

hhh = ddd(3, kkk(4))  # kkk(4) возвращает 8, затем ddd(3, 8)
print(hhh)
=
11

#После выполнения return функция заканчивает своё выполнение.
#Python также позволяет возвращать несколько значений с помощью return.
def h():
    x = 10
    y = 20
    return x, y	# Возврат нескольких значений

g = h()		# coords будет кортежем (10, 20)
print(g)
=
(10, 20)

#Также return часто используется в условных
#операторов для возврата различных значений в зависимости от условий:
def h(k):
    if k > 0:
        return "Положительное число"
    elif k < 0:
        return "Отрицательное число"
    else:
        return "Ноль"

t = h(5)
print(t)
=
Положительное число
------------------------------------------------------------------------------
#raise останавливает выполнение текущей функции или блока кода.
#
Если исключение не обрабатывается (нет блока try-except),
#оно остановит всю программу.
#
Если исключение обрабатывается с помощью try-except,
#программа может продолжить работу после обработки.
------------------------------------------------------------------------------
#Пример 1: raise в функции без обработки

def c(d):
    if d < 0:
        raise ValueError("Число не должно быть отрицательным!")

print("Начало программы")
c(-5)  					# Здесь произойдёт ошибка
print("Эта строка не будет выполнена")
=
ValueError: Число не должно быть отрицательным!

#В этом примере, как только вызывается raise,
#выполнение программы остановится,
#и строка print("Эта строка не будет выполнена") никогда не выполнится.
#Программа завершится с сообщением об ошибке.
------------------------------------------------------------------------------
#Пример 2: raise с обработкой исключения

def c(d):
    if d < 0:
        raise ValueError("Число не должно быть отрицательным!")
try:
    c(-5)
except ValueError as e:
    print(f"Обработано исключение: {e}")
print("Программа продолжает работу")
=
Обработано исключение: Число не должно быть отрицательным!
Программа продолжает работу

#Здесь ошибка ValueError обрабатывается в блоке except,
#поэтому программа не завершится аварийно.
------------------------------------------------------------------------------